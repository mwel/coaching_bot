\chapter{Implementierung} \label{Implementierung}


    Die im Kapitel \ref*{Realisierung} Realisierung erarbeiteten Ansätze wurden umgesetzt. Die Systeme und Ergebnisse werden im Folgenden beschrieben. Bevor die eigentliche Implementierung beginnen kann, muss zunächst eine Art Bot-Rohling registriert werden. Daraufhin kann ein Template verwendet oder ein ganz neuer Bot implementiert werden. Als ersten Schritt zur Erschaffung eines Telegram-Bots wird der Bot-Father\footnote{\url{https://core.telegram.org/bots\#6-botfather}} konsultiert. Er erstellt das Framework, registriert den Bot und gibt ein API-Token zurück, das verwendet werden kann, um sich gegenüber der Telegram-Bot-API als Entwickler zu identifizieren. \cite{telegramAPI} Das Token dient als einzige Identifikationsmethode. Jeder, der in Besitz des Schlüssel ist, kann den zugehörigen Bot theoretisch nutzen und bearbeiten. Das Token ist also an einem sicheren Ort aufzubewahren und nicht in einer öffentlichen Versionierung freizugeben.
    Als Basis (boiler plate) für den Bot nutzen wir die breit in der Community abgestütze Implementierung \textbf{Conversation Bot} \cite{conversationBot}. Sie stellt uns eine basale Implementierung einer State Machine zur Verfügung, die in der Implementierung erheblich ausgebaut wird, uns aber als guter Einstieg dient. Im Gegensatz dazu ist der \glqq Nested Converation Bot\grqq schon bei Weitem zu umfangreich und zu mächtig für unsere Zwecke.






    \section{main.py - Anmeldung Bot, Updater, Dispatcher und Handler-Konfiguration} \label{main.py}
        Auf die Mechanismen der \verb|main.py|-Funktion wird in den folgenden drei Code-Abschnitten eingegangen:
        \begin{lstlisting}[language=Python, caption={bot/main.py(1) - Authentifizierung und Schlüssel-Übergabe an den Updater}\label{code: bot/main.py 1}]
# Hand over API_TOKEN to the bot
bot = telegram.Bot(token=API_KEY)

def main() -> None:
# Creates the updater and passes the API_TOKEN to it.
updater = Updater(API_KEY)
        \end{lstlisting}
        Die \verb|main.py|-Funktion importiert alle Handler, authentifiziert sich gegenüber der Telegram API (wie im oben stehenden Listing 6.1 zu sehen), instanziiert den Bot und seinen Dispatcher und bindet dann in einem genesteten Aufbau Message- und Command-Handler and Conversation-Handler und diese wiederum an den Dispatcher, um den Bot in einen Zustand zu versetzen, in dem er Befehle entgegennehmen und entsprechend reagieren kann. \\
        
        Dispatcher liefern Nachrichten an den Nutzer aus. Pro Bot gibt es grundsätzlich mind. einen Dispatcher. Der Coaching Bot hat aber mehrere für mehrere Konversationsstränge. An den Dispatcher werden Conversation- sowie Command-Handler gebunden und konfiguriert (wie im untenstehenden Listing 6.2 ersichtlich).\\
        Der Conversation-Handler bildet die in Abb. \ref*{fig: state machine} konzipierte State Machine ab. Als solche, kontrolliert er den Konversationsfluss zwischen dem Nutzer und dem Bot. Pro Bot kann es mehrere Conversation-Handler geben. Der Coaching Bot hat aber nur Einen: den \verb|conv_handler|. Der Conversation-Handler koordiniert alle im Haupt-Konversationsfluss enthaltenen Command-Handler.\\
        Pro Zustand aus der State Machine gibt es einen Command-Handler. Für jeden Command-Handler gibt es ein Set an Kriterien und / oder einen Befehl, der die zugeordnete Zustands-Funktion auslöst. i.e. den Befehl \verb|/start| für die Funktion \verb|start| aus \verb|start.py| im gleichnamigen Command-Handler, der hier als Einstiegspunkt definiert ist. Funktionen werden nur mittelbar vom Nutzer und unmittelbar von der State-Machine ausgelöst.\\
        Befehle werden vom Nutzer eingegeben und vom Message-Handler entgegengenommen. Ein Message-Handler prüft die Eingabe eines Nutzers in einem bestimmten Zustand auf vordefinierte Kriterien und meldet das Ergebnis an den Conversation-Handler zurück, der auf dieser Basis dann entscheidet, ob er die zugehörige Zustands-Funktion auslöst oder nicht. Diese Kriterien werden direkt in der main.py in einem der Message-Handler definiert. \\
        Handler-Funktionen sind Zustands-Funktionen (siehe \ref*{Realisierung: state functions}). Sie werden ausgelöst, wenn Eingaben vom Message-Handler als valide interpretiert werden. 

        \begin{lstlisting}[language=Python, caption={bot/main.py(2) - Dispatcher, Conversation- \& Command-Handler} \label{code: bot/main.py 2}]
    # Gets the dispatcher to register handlers
    dispatcher = updater.dispatcher
    
    # bot state machine and main conversation handler
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start)],
        states={
            states.BIO:         [MessageHandler
                (Filters.text& ~Filters.command, bio), 
                CommandHandler('skip', skip_bio)],
            states.GENDER:      [MessageHandler
                (Filters.regex('^(Gentleman|Lady|Unicorn)$'),gender), 
                CommandHandler('skip', skip_gender)],
            states.BIRTHDATE:   [MessageHandler
                (Filters.text& ~Filters.command, birthdate), 
                CommandHandler('skip', skip_birthdate)],
            states.EMAIL:       [MessageHandler
                (Filters.text& ~Filters.command, email), 
                CommandHandler('skip', skip_email)],
            states.TELEPHONE:   [MessageHandler
                (Filters.text& ~Filters.command, telephone), 
                CommandHandler('skip', skip_telephone)],
            states.LOCATION:    [MessageHandler
                (Filters.location& ~Filters.command, location), 
                CommandHandler('skip', skip_location)],
            states.PHOTO:       [MessageHandler
                (Filters.photo   & ~Filters.command, photo), 
                CommandHandler('skip', skip_photo)],
            states.SUMMARY:     [MessageHandler
                (Filters.regex('^(COMPLETE SIGN UP)$'),  summary)],
            states.APPOINTMENT: [MessageHandler
                (Filters.text& ~Filters.command, appointment), 
                CommandHandler('skip', skip_appointment)],
            # more states here...
            },
            fallbacks = [CommandHandler('cancel', cancel)],
    )

    dispatcher.add_handler(conv_handler)
    # more conversation handlers for secondary commands
    dispatcher.add_handler(CommandHandler('summary', summary))
    dispatcher.add_handler(CommandHandler('delete', delete))
    dispatcher.add_handler(CommandHandler('status', status))
        \end{lstlisting}

        Über die folgenden Befehle, werden die entsprechenden, gleichnamigen Command-Handler und Funktionen ausgelöst: 
        \begin{itemize}
            \item \verb|/start| - startet den Konversationsfluss
            \item \verb|/cancel| - beendet den Konversationsfluss, löscht Nutzerdaten aus der Datenbank und informiert entsprechend
            \item \verb|/delete| - löscht Nutzerdaten des Nutzers und informiert ihn
            \item \verb|/help| - gibt die Hilfe aus
            \item \verb|/summary| - gibt die Zusammenfassung für den Nutzer aus
            \item \verb|/status| - gibt gibt den aktuellen Fortschritt für den Nutzer aus
        \end{itemize}
        Der in dieser Applikation umfangreichste Conversation-Handler umfasst zwei Befehle: \verb|/start| und \verb|/cancel|. Solange der Bot ausgeführt wird, lässt sich ein Konversationsfluss mit ihm über den Befehl \verb|/start| starten und via \verb|/cancel| beenden. (Zur Funktionsweise der den Befehlen zugeordneten Zustands-Funktionen siehe den entsprechden Abschnitt unter \ref{Implementierung: Handler Functions}.) \\ \\
        
        Schließlich wird die State Machine des Coaching Bots gestartet. Über das sog. Polling werden Aktualisierungen konstant von Telegram nachgeladen. Der Bot ist aktiv (idle) und wartet darauf, Befehle entgegenzunehmen.
        \begin{lstlisting}[language=Python, caption={bot/main.py(3) - Start Polling \ Idle}\label{code: bot/main.py 3}]
    # Start the Bot
    updater.start_polling()

    updater.idle()
        \end{lstlisting}

        \subsection{states.py - Zustände zentral verwalten} \label{Implementierung: states.py}
            Die State Machine (der Conversation-Handler) muss zu jeder Zeit wissen, welche Zustände es gibt und in welcher Reihenfolge diese existieren. Dazu nutzt der Bot ein Array aus Konstanten (\verb|STATES|). So lässt sich die Reihenfolge der Zustände auch ganz leicht ändern. Soll der Bot bspw. E-Mail und Telefonnummer zu Anfang abfragen oder sollen einige Schritte aus dem Konversationsfluss genommen werden, so sind diese hier einfach zu entfernen und die Nachrichten in den eizelnen Zustands-Funktionen leicht anzupassen.\\
    
            Um Nachrichten an den Nutzer zentralisiert zu verwalten, verweisen Handler-Funktionen wo immer möglich auf eine Konstante aus dem \verb|MESSAGES|-Dictionary. So wird vermieden, dass Strings bei Anpassungen der Zustände oder deren Reihenfolge in mehreren Dateien angepasst werden müssen.\\
        
            Gleiches gilt für individuelle Tastaturen aus dem \verb|KEYBOARDS|-Dictionary. 











    \section{Rahmen- und Meta-Funktionen}
        Die in Kapitel \ref*{Realisierung} Realisierung beschriebenen Rahmen- und Meta-Funktionen wurden folgendermaßen umgesetzt:

        \subsection{start.py - Beginn und Weiterführung des Konversationsflusses} \label{Implementierung: start.py}
        In sechs Abschnitten wird nun die wichtige Funktion \verb|start| beschrieben. Sie fungiert als Eingangstor für jeden Nutzer. Wann immer der Befehl \verb|/start| an den Bot schickt wird, löst der Command-Handler die Funktion \verb|start| aus.\\
        Zunächst wird geprüft, ob es eine Datenbank gibt. Ist dies der Fall, wird geprüft, ob der Nutzer, der die Funktion ausgelöst hat, bereits in der Datenbank existiert. Ist dies wiederum der Fall, gibt die Funktion eine Willkommen-zurück-Nachricht aus.

% Code Abschnitt 1 aus start.py
            \begin{lstlisting}[language=Python, caption={start.py - Aufbau DB und Prüfung ob Nutzer bekannt}\label{code: start.py(1)}]
def start(update: Update, context: CallbackContext) -> int:
    # CREATE DB, IF NOT EXISTS
    create_db()

    user_id = update.message.from_user.id

    user_exists = select_db.user_search(user_id)
    if user_exists:
        # get user's state from db
        state = int(select_db.get_value(user_id, 'state'))

        update.message.reply_text(
            f'Welcome back {update.message.from_user.first_name},\n'
            'Let\'s continue where we left off...',
            reply_markup=ReplyKeyboardRemove(),
            )
            \end{lstlisting}
% Code Abschnitt 2 aus start.py
            Nun wird abhängig vom für den Nutzer gespeicherten Zustand zwischen unterschiedlichen Reaktionen differenziert. Befindet der Nutzer sich im Zustand \verb|SUMMARY|, hat also bereits alle Fragen beantwortet, aber noch keinen Termin vereinbart, so werden in diesem Zustand sinnvolle Optionen empfohlen. Der Nutzer kann sich den Status seiner Bewerbung ausgeben lassen, die Zusammenfassung erneut beantragen oder alle seine Daten löschen.
            \begin{lstlisting}[language=Python, caption={start.py - Zustand Zusammenfassung}\label{code: start.py(2)}]
        if state == states.SUMMARY:  
        # sign up was apparently already completed for this user
            reply_keyboard = [
                ['/status'], 
                ['/summary'],
                ['/delete']]
            update.message.reply_text(
            'Ah! I see, you have already completed 
            the sign up.\nYou now have multiple options below:\n'
            'If you have not made an appointment yet 
            and would like to do so, enter /summary.\n\n'
            'If you want to /delete your record entirely, 
            press /delete.',
            reply_markup=ReplyKeyboardMarkup(
            reply_keyboard, one_time_keyboard=True, 
            input_field_placeholder='SIGN UP COMPLETE'
                )
            )
            \end{lstlisting}
% Code Abschnitt 3 aus start.py
            Befindet der Nutzer sich im Zustand \verb|APPOINTMENT|, hat aber noch keinen Termin vereinbart, die Zusammenfassung aber bereits erhalten, erhält er zusätzlich zur Option, sich die Zusammenfassung erneut ausgeben zu lassen und so die Terminfindung zu starten, nur die Status- und Lösch-Optionen. Natürlich kann der Nutzer auch manuell alle Befehle jederzeit eingeben, aber die Tastatur ist so für Optionen vordefiniert, dass der Nutzer in eine bestimmte Richtung gelenkt wird. Nach der Ausgabe dieser Nachricht, beendet der Conversation-Handler die Kommunikation.
            \begin{lstlisting}[language=Python, caption={start.py - Zustand Terminvereinbarung(noch nicht vereinbart)}\label{code: start.py(3)}]
        elif state == states.APPOINTMENT and select_db.get_value(user_id, 'appointment') == 'None':
            reply_keyboard = [
                ['/status'], 
                ['/delete']]
            update.message.reply_text(
            'If you have not made an appointment yet 
            and would like to do so, enter /summary.\n\n',
            reply_markup=ReplyKeyboardMarkup(
            reply_keyboard, one_time_keyboard=True, 
            input_field_placeholder='SIGN UP COMPLETE'
            )
        )
            return ConversationHandler.END
            \end{lstlisting}

% Code Abschnitt 4 aus start.py
            Befindet der Nutzer sich im Zustand \verb|APPOINTMENT| und hat bereits einen Termin vereinbart, so werden Informationen zu dem Termin aus der Datenbank abgerufen und direkt ausgegeben. Auch in diesem Fall wird die Konversation nun beendet, da keine weiteren Interaktionen mit dem Nutzer vorgesehen sind.
            \begin{lstlisting}[language=Python, caption={start.py - Zustand Termin (bereits vereinbart)}\label{code: start.py(4)}]
        elif state == states.APPOINTMENT:
            appointment_made = select_db.get_value(user_id, 
            'appointment')
            reply_keyboard = [
                ['/status'], 
                ['/delete']]
            update.message.reply_text(
            f'Cool. You already have an appointment on 
            {appointment_made} \n\n'
            'In case you would like to cancel, 
            you can do that via your calendar app.\n\n'
            'Otherwise, we are looking forward to our call.',
            reply_markup=ReplyKeyboardMarkup(
            reply_keyboard, one_time_keyboard=True, 
            input_field_placeholder='SIGN UP COMPLETE'
            )
        )
            return ConversationHandler.END
            \end{lstlisting}
            Egal für welchen Fall die Funktion sich entscheidet, der Nutzer wird immer korrekt in den Konversationsfluss zurückgeführt und zwar genau vor der Frage, die zuletzt nicht beantwortet wurde.\footnote{Eine Frage zu überspringen gilt dabei auch als Beantwortung.} Dazu wird die Datenbank abgefragt und der Wert aus \verb|state| für die entsprechende \verb|user_id| an den Conversation-Handler weitergegeben. Dieser präsentiert als Antwort darauf die nächste Frage im Konversationsfluss. \\
% Code Abschnitt 5 aus start.py
            \begin{lstlisting}[language=Python, caption={start.py - Weiterleitung in Zustand} \label{code: start.py(5)}]

            # call next function for user
            update.message.reply_text(states.MESSAGES[state], reply_markup=states.KEYBOARD_MARKUPS[state])
            return state
            \end{lstlisting}

% Code Abschnitt 6 aus start.py
            Treffen all diese Konditionen nicht zu, wurde der Nutzer also nicht in der Datenbank gefunden, so startet der Bot ganz normal mit einer Begrüßung, nachdem initiale Daten von der Telegram-Instanz des Nutzers abgefragt und in die Datenbank geschrieben wurden. \\
            Ist die Nachricht an den Nutzer ausgeliefert, aktualisiert der Bot den Zustand für den Nutzer in der Datenbank, damit der Bot weiß, welche Fragen der Nutzer schon beantwortet hat und er den Nutzer bei einer Rückkehr wieder am richtigen Punkt in den Konversationsfluss einfügen kann.\\
            Bevor der Bot den Nutzer zur nächsten Stufe weiterleitet, speichert er noch einen Zeitstempel, damit man nachvollziehen kann, wann der Nutzer seinen Prozess begonnen hat.
            \begin{lstlisting}[language=Python, caption={start.py - Standard Einstieg Konversationsfluss} \label{code: start.py(6)}]

        logger.info(f'+++++ NEW USER: {update.message.from_user.first_name} 
        {update.message.from_user.last_name} +++++')

        # write user info to db
        insert_update(user_id, 'first_name', update.message.from_user.first_name) 
        insert_update(user_id, 'last_name', update.message.from_user.last_name)
        insert_update(user_id, 'appointment', 'None')
        insert_update(user_id, 'event_id', '0')

        update.message.reply_text(
            f'Hi {update.message.from_user.first_name},\n'
            'I am a coaching bot by wavehoover. You have 
            taken the first step on your journey to success 
            by contacting me. I will guide you through the 
            application process for your first coaching session. '
            'It\'s super easy. Just follow the questions, answer 
            or skip them - that\'s it.\n\n'
            '[You can send /cancel at any time, if you are 
            no longer interested in a conversation.]\n\n'
            f'Now, {update.message.from_user.first_name} - 
            {states.MESSAGES[states.BIO]}',
            reply_markup=ReplyKeyboardRemove(),
            )

        # save state to DB
        insert_update(user_id, 'time_stamp', datetime.now())
        insert_update(user_id, 'state', states.BIO)
        return states.BIO
            \end{lstlisting}

        \subsection{cancel.py - Konversationen beenden und Nutzerdaten löschen} \label{Implementierung: cancel.py}
            Wurde eine Konversation mit dem Bot gestartet und noch nicht beendet, so kann diese auch manuell beendet werden. Über den Befehl \verb|/cancel|, der im Conversation-Handler als Fallback definiert ist, wird die Funktion \verb|cancel| aufgerufen, alle Daten des Nutzers aus der Datenbank gelöscht und eine Bestätigung an den Nutzer ausgegeben. Sollte es bei diesem Vorgang zu einem Fehler kommen, so wird der Nutzer auch darüber benachrichtigt.\footnote{Eine Ausnahme tritt auf, wenn der Nutzer seine Daten bereits gelöscht und den Bot noch nicht neu gestartet hat - es ihn also in der Datenbank gar nicht gibt oder (sehr selten), falls die SQL-Operation nicht erfolgreich war.} Schließlich beendet der Bot die Konversation.\\ \\

            Wurde eine Konversation bereits beendet, kann der Conversation-Handler nicht mehr auf den Befehl \verb|/cancel| reagieren. Für diesen Fall gibt es einen extra Dispatcher, der auf den Befehl \verb|/delete| hört und die Daten des Nutzers ebenfalls restlos löscht. So ist sichergestellt, dass der Nutzer seine Daten auch löschen kann, wenn die Konversation mit dem Bot aus irgendeinem Grund unterbrochen oder bereits beendet wurde.

        \subsection{help.py - Hilfe ausgeben} \label{Implementierung: help.py}
            Die Funktion \verb|help| ist eine Meta-Funktion und gibt durch Aufruf des Befehls \verb|/help| die Hilfe aus. Sie setzt ein sog. Dictionary aus einer Liste an Befehlen zusammen, das flexibel befüllt und dann ausgegeben werden kann. Ein Dictionary bietet die Möglichkeit, die Hilfe jederzeit einfach anzupassen, um Elemente zu erweitern oder zu reduzieren ohne die Logik, über die die Hilfe ausgegeben wird, zu beeinflussen. Dazu wird die \verb|collections|-Bibliothek eingebunden, die es erlaubt, ein geordnetes Dictionary zu erstellen. Nachdem der String für die Hilfe zusammengesetzt ist, wird dieser einfach via der Funktion \verb|send\_message| ausgegeben.








    \section{Aufbau und Beispiele Zustands-Funktionen(Handler-Funktionen)} \label{Implementierung: Handler Functions}
        Im Folgenden gehen wir detailliert auf die einzelnen Handler-Funktionen ein, beschreiben deren Umfang und Aufbau und erklären ihre Funktionsweise. Übergänge sind nach dem in Abschnitt \ref{Grundlagen: ConversationBot} skizzierten Format der \verb|state[n]|-Methoden aufgebaut. Die Funktion \verb|bio| in der \verb|bio.py| speichert die Text-Eingabe eines Nutzers als erste Nutzereingabe nach dem \verb|/start|-Befehl. Sie repräsentiert besonders gut den Aufbau der Handler-Funktionen, weil sie über das Speichern und weiterleiten keine weiteren Features besitzt. Daher erläutern wir den Aufbau der Handler-Funktionen beispielhaft anhand der Funktion \verb|bio| für alle anderen Handler-Funktionen. Der Aufbau aller weiteren Handler-Funktionen ähnelt der Funktion \ref*{code: bio.py}. Auf signifikante Erweiterungen und Anpassungen wird in den entsprechenden Abschnitten eingegangen.

            \begin{lstlisting}[language=Python, caption={bio.py - Beispiel einer Handler-Funktion} \label{code: bio.py}]
# Stores the information received and continues on to the next state
def bio(update: Update, context: CallbackContext) -> int:
    
    user_id = update.message.from_user.id
    bio_message = update.message.text
    
    # write info to DB
    insert_update(user_id, 'bio', bio_message)

    # reply keyboard for next state
    update.message.reply_text(
        'What a story! We will definately pick that up 
            in our first session!\n\n' + \
        'Ok - now let\'s get some basics down: \n' + \
        states.MESSAGES[states.GENDER],
        reply_markup=states.KEYBOARD_MARKUPS[states.GENDER],
        )

    # save state to DB
    insert_update(user_id, 'state', states.GENDER)
    return states.GENDER
            \end{lstlisting}

            Zunächst werden ein Update- und ein CallbackContext-Objekt an die Handler-Funktion übergeben. Zurückgegeben wird der Datentyp \verb|int|, da die State-Machine am Ende der Funktion wissen muss, in welchen Zustand der Nutzer als nächstes geschickt werden soll und die Zustände nummeriert sind. \\
            Innerhalb der Funktion werden \verb|user_id| und \verb|bio_message| aus dem Update-Objekt gespeichert, da diese beiden informationen als nächstes in die Datenbank gespeichert werden sollen. Die \verb|bio_message| ist in diesem Fall die Text-Eingabe, die an den Bot übermittelt wurde. Die \verb|user_id| ist die Telegram-ID des jeweiligen Nutzers, an die alle Nutzerinformationen geknüpft werden.
            (zur Funktionalität der \verb|insert_update|-Funktion siehe Abschnitt \ref{Implementierung: insert_value_db.py} insert\_value\_db.py - Werte schreiben)
            Die Hintergrundprozesse sind nun abgeschlossen und die für den Nutzer sichtbare Reaktion auf seine Nachricht kann erfolgen. Die Funktion \verb|update.message.reply_text| erlaubt es uns, dem Nutzer einen beliebigen String sowie eine für diese Nachricht individuelle Antwort-Tastatur auszugeben. (Die zu übergebenden Parameter für die Zustandsbergänge sind für die \verb|reply_text|-Instanzen in der \verb|states.py| zentral gespeichert, um sich innerhalb der einzelnen Handler-Funktion soweit als möglich von Inhalten zu abstrahieren.)
            Ist die Ausgabe an den Nutzer erfolgt, bleibt noch die Aktualisirung des neuen Zustands des Nutzers in der Datenbank, gefolgt von der Übergabe des nächsten Zustands an den ConversationHandler. Damit ist die Zustands-Funktion beendet und der Übergang von einem in den nächsten Zustand abgeschlossen. Diese Funktion leitet in den Zustand \verb|GENDER|.\\ \\

                Im Zustand \verb|START| ist, wie aus der State Machine ersichtlich, noch eine zweite Funktion verfügbar. Die \verb|skip_bio| kann vom Nutzer durch den Befehl \verb|/skip| ausgelöst werden. Dieser Befehl ist in jedem Zustand spezifisch für den Command-Handler dieses Zustands definiert und hat in jedem Zustand einen angepassten Effekt. Anhand der Funktion \verb|skip_bio| wird wieder beispielhaft aufgezeigt, wie \verb|skip|-Funktionen aufgebaut sind:

            \begin{lstlisting}[language=Python, caption={skip\_bio.py - Zustände überspringen} \label{code: skip_bio.py}]
# Skips this information and continues on to the next state
def skip_bio(update: Update, context: CallbackContext) -> int:
    
    user_id = update.message.from_user.id

    # alternative message
    update.message.reply_text(
        'Alright. No problem...', # individual skip message
        reply_markup=ReplyKeyboardRemove(),
        )
    # reply keyboard for next state
    update.message.reply_text(
        states.MESSAGES[states.GENDER],
        reply_markup=states.KEYBOARD_MARKUPS[states.GENDER],
        )    

    # save state to DB
    insert_update(user_id, 'state', states.GENDER)
    return states.GENDER
            \end{lstlisting}

                Der Aufbau ähnelt zwar der \verb|bio|-Funktion, allerdings liegt hier ein reduzierter Umfang und eine andere Nachricht an den Nutzer vor. Ein Update der Datenbank fällt zudem weg, da der Nutzer keine neuen Informationen angegeben hat. Hier werden zwei \verb|reply_text|-Funktionen hintereinander verwendet. Die Erste dient dazu, eine auf diese \verb|skip|-Funktion individuelle Nachricht zu übermitteln. Die Zweite  übermittelt die Aufforderung zur Eingabe der Information für die nächste Stufe und zeigt die entsprechende Tastatur an. Alle weiteren \verb|skip|-Funktionen sind ähnlich aufgebaut.\\
                Der Zustand \verb|EMAIL| ist der einzige Zustand, der nicht übersprungen werden kann. Ohne eine gültige E-Mail-Adresse des Nutzers können wichtige Folgefunktionen des Bots nicht genutzt werden und der Sinn und Zweck (eine Terminvereinbarung) kann nicht erfüllt werden. Daher ist die Funktion \verb|skip_email| so gestaltet, dass sie keinen Zustand zurückgibt, sondern den Nutzer immer im aktuellen Zustand belässt. Es bleiben die Optionen, eine gültige Adresse anzugeben oder die Konversation zu beenden.\\ \\

        \paragraph{Nach den beiden exemplarisch vorgestellten Funktionen wird im weiteren Verlauf des Kapitels nur noch auf Besonderheiten der restlichen Handler-Funktionen eingegangen.}

        \subsection{Handler-Funktionen mit Input Validation} \label{Implementierung: handler validation}
            Der Bot arbeitet in den Funktionen \verb|birthdate|, \verb|email| und \verb|telephone| mit Input-Validierung. (zur Funktionsweise siehe \ref{Implementierung: validation.py} validation.py) Dazu wird die Nutzereingabe zunächst an die Funktion \verb|validate_birthdate| übergeben und auf die Bewertung des Inputs gewartet. 
            \begin{lstlisting}[language=Python, caption={birthdate.py - Input Validation}\label{code: birthdate.py}]
def birthdate(update: Update, context: CallbackContext) -> int:

    if validate_birthdate(update.message.text): # if entry is valid, continue.
        insert_update(update.message.from_user.id, 'birthdate', update.message.text)
        update.message.reply_text(...
        insert_update(update.message.from_user.id, 'state', states.EMAIL)
        return states.EMAIL

    else: # else, tell user and stay in current state until correct entry is provided.
        update.message.reply_text(
        f'Sorry, that\'s not a valid entry. Please try again.',
        reply_markup=ReplyKeyboardRemove(),
        )
            \end{lstlisting}
                
            Entspricht der Input dem prädefinierten Format, fährt der Bot wie gewöhnlich fort und übergibt den nächsten Zustand zurück an den Conversation-Handler. Ist dies jedoch nicht der Fall, so wird (wie in Listing 6.12 ersichtlich) eine entsprechende Nachricht an den Nutzer ausgegeben. Da der Conversation-Handler erst dann zur nächsten Stufe geht, wenn er von der Funktion \verb|birthdate| den entsprechenden Zustand zurückerhalten hat, entsteht hier ein Loop, der entweder durch eine gültige Eingabe oder i.e. den Befehl \verb|/skip| gebrochen werden kann.
        
            
        % \subsection{telephone.py} \label{Implementierung: telephone.py}
        %     %\subsubsection{Funktion telephone}
        %         Die Funktion \verb|telephone| funktioniert exakt gleich wie die Funktion \verb|email|.

        %     %\subsubsection{Funktion skip\_telephone}
        %         Die Funktion \verb|skip_telephone| bietet dem Nutzer an, den Kontakt mit dem Anbieter alternativ via dem auf der Internetseite verfügbaren Webformular zu suchen. \footnote{Dies ist generell für alle Informationen möglich, die an den Bot übergeben werden, allerdings lag der Beweggrund für die Erstellung des Bots darin, eine Alternative zum klassischen Kommunikationsmedium Web-Formular zu bieten.}
        
        
        % \subsection{location.py} \label{Implementierung: location.py}
        %     %\subsubsection{Funktion location}
        %         Der Nutzer hat hier die Möglichkeit, seinen Standort anzugeben. Dazu wird die bereits in Telegram vorhandene Funktion zur Standortfreigabe genutzt. \\
        %         Am Ende der Funktion, bevor der Bot zur nächsten Stufe \verb|PHOTO| weitergeht, sendet der Bot ein Bild von sich selbst, um den Nutzer dazu anzuregen, auch ein Bild von sich zu teilen. Dazu wird ein einfaches JPG verwendet, das im Repository des Bots gespeichert ist. Der Pfad kann leicht an jede andere Ressource angepasst werden.

        %     %\subsubsection{Funktion skip\_location}
        %         %Keine Besonderheiten.
        

        % \subsection{photo.py} \label{Implementierung: photo.py}
        %     %\subsubsection{Funktion photo}
        %         Entscheidet der Nutzer sich, ein Bild mit dem Bot zu teilen, so nimmt die Funktion \verb|photo| dieses entgegen und speichert es in einem Ordner, der je nach System gewählt werden kann. Hier wurde ein Ordner im gleichen Verzeichnis gewählt, in dem der Bot existiert. Um Bilder später wieder zuordnen zu können, wird der Dateiname jedes Bildes auf die user\_ID des jeweiligen Nutzers gesetzt, bevor es gespeichert wird.

        %     %\subsubsection{Funktion skip\_photo}
        %         %Keine Besonderheiten.

        \subsection{validation.py - Input-Validierung} \label{Implementierung: validation.py}
            Die drei Input-Validation-Funktionen sind einander ähnlich per \verb|try/except| oder \verb|if/else| Block aufgebaut:

            Die Funktion \verb|validate_birthdate| bekommt die Nutzereingabe übergeben und vergleicht diese via der Funktion \verb|strptime| aus der \verb|datetime|-Bibliothek \cite{datetime} mit dem in der DACH-Region gängigen Datums-Format: \verb|TT.MM.JJJJ| \\
            Stimmt die Eingabe mit dem definierten Format überein, gibt die Funktion \verb|True| zurück. Ansonsten wird ein \verb|ValueError| geloggt und die Funktion gibt \verb|False| zurück.\\ 
            \\
            Die Funktion \verb|validate_email| bedient sich eines regulären Ausdrucks, um zu prüfen, ob die Eingabe eine E-Mail sein könnte: \\
            \\
            \verb/[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}/\footnote{Ein vollumfänglicher regulärer Ausdruck, ein externder Dienst oder gar das versenden einer Test-E-Mail wurden aus Performance-Gründen ausgeschlossen.} \\ 

            Ist der Vergleich erfolgreich, gibt die Funktion \verb|True| zurück, ansonsten \verb|False|. \\
            \\
            Auch Telefonnummern werden via regulärem Ausdruck geprüft: \\
            \\\verb/^\+4[139]\d{9,12}$/ \\
            \\
            Zugelassen sind so alle Telefonnummern aus Deutschland, Österreich und der Schweiz.\\
            Ist der Vergleich erfolgreich, gibt die Funktion \verb|validate_telephone| \verb|True| zurück, ansonsten \verb|False|.
        

        \subsection{summary.py - Zusammenfassung für den Nutzer} \label{Implementierung: summary.py}
            In der Funktion \verb|summary| kommt alles zusammen. Der Nutzer hat nun alle Angaben gemacht oder übersprungen und befindet sich im Zustand \verb|SUMMARY|. \\
            Die Funktion \verb|summary|, wie in den kommenden vier Code-Abschnitten aufgezeigt, beginnt damit, eine Reihe von Informationen von der Datenbank abzufragen und in Variablen zu speichern. Es werden nur Informationen abgefragt, die auch in der auszugebenden Nachricht genutzt werden sollen. Direkt darauf wird ein String für die zu versendende Nachricht zusammengesetzt und gespeichert. Es folgt eine einfache \glqq Danke-Nachricht\grqq an den Nutzer:

            \begin{lstlisting}[language=Python, caption={summary.py(1) - Zusammenfassung für den Nutzer direkt im Messenger} \label{code: summary.py(1)}]
def summary(update: Update, context: CallbackContext) -> int:
    
    user_id = update.message.from_user.id    

    first_name = get_value(user_id, 'first_name')
    last_name = get_value(user_id, 'last_name')
    gender = get_value(user_id, 'gender')
    birthdate = get_value(user_id, 'birthdate')
    email = get_value(user_id, 'email')
    telephone = get_value(user_id, 'telephone')

    summary = f"""
        Given Name:\t\t{first_name}
        Last Name:\t\t{last_name}
        Gender choice:\t\t{gender}
        Birthdate:\t\t\t{birthdate}
        Email address:\t\t{email}
        Phone number:\t{telephone}
        """

    # confirmation message
    update.message.reply_text(
        f'Thanks for signing up, {update.message.from_user.first_name}!\n\n'
        f'SUMMARY for {update.message.from_user.first_name} 
        {update.message.from_user.last_name}:\n\n{summary}',
        reply_markup=ReplyKeyboardRemove(),
    )
            \end{lstlisting}
            Nun prüft der Bot, ob der Nutzer bereits einen Termin vereinbart hat:
            
            \paragraph{Option A} Der Nutzer ist bis zum Zustand \verb|SUMMARY| gekommen, hat die Zusammenfassung ausgegeben bekommen, dann aber keinen Termin vereinbart und den Chat verlassen. Der Nutzer kehrt nun zum Chat zurück und gibt erneut \verb|/start| ein, um seine Konversation wieder aufzunehmen. Der Bot findet den Nutzer in der Datenbank und leitet ihn an die Stufe \verb|SUMMARY| weiter, um direkt vor der Terminvergabe (Zustand \verb|APPOINTMENT|) einzusetzen. Der Nutzer kann nun einen Termin vereinbaren und durchläuft die folgenden zwei Schritte: 
                \begin{enumerate}
                    \item Der Bot versucht, dem Nutzer jetzt drei mögliche Terminvorschläge zu unterbreiten und startet dazu die Terminfindung (siehe \ref{Implementierung: Kalender} Kalender).
                    \item Sobald die Termine zurückkommen, präsentiert der Bot diese dem Nutzer in Form eines entsprechenden Tastatur-Layouts.\footnote{Das Layout ist dabei dynamisch und generiert sich bei jeder Anfrage neu.}
                \end{enumerate}
            
            \begin{lstlisting}[language=Python, caption={summary.py(2) - Prüfung Termin negativ} \label{code: summary.py(2)}]
    # check, if the user already made an appointment. 
    appointment_made = get_value(user_id, 'appointment')
    
    # If yes, make one. Else, inform.
    if appointment_made == 'None':
        
        update.message.reply_text(
            'Ok. We will look for 3 appointment options 
            you can choose from for your phone call. \n\n'
            '... SEARCHING ...',
            reply_markup=ReplyKeyboardRemove(),
        )

        free_slots = find_slots()

        slot1 = str(free_slots[0])
        slot2 = str(free_slots[1])
        slot3 = str(free_slots[2])

        # next step message
        update.message.reply_text(
            states.MESSAGES[states.APPOINTMENT],
            reply_markup=ReplyKeyboardMarkup(
                [[slot1], [slot2], [slot3]], ['/skip'], 
                one_time_keyboard=True, 
                input_field_placeholder='Choose your slot...'
                )
            )
            \end{lstlisting}
            
            \paragraph{Option B}
            Der Nutzer ist bis zum Zustand \verb|SUMMARY| gekommen und hat bereits einen Termin vereinbart. In diesem Fall fragt der Bot den Termin von der Datenbank ab und gibt ihn in einer Nachricht an den Nutzer zurück. Gleichzeitig schlägt er dem Nutzer weitere mögliche Befehle vor, die an dieser Stelle Sinn machen und beendet die Konversation.            
            
            \begin{lstlisting}[language=Python, caption={summary.py(3) - Prüfung Termin positiv} \label{code: summary.py(3)}]
    else:
        update.message.reply_text(
            f'Cool. You already have an appointment: {appointment_made} \n\n'
            'In case you would like to cancel, you can do so via your calendar app.\n\n'
            'Otherwise, we are looking forward to our call.',
            reply_markup=ReplyKeyboardRemove(),
        )

        return ConversationHandler.END
            \end{lstlisting}

        Schließlich wird die Funktion \verb|confirmation_mail| aufgerufen, die die gleiche Zusammenfassung nochmals per E-Mail an die Adresse des Nutzers sendet (siehe \ref{Implementierung: confirmation_mail.py} confirmation\_mail.py) und die Information darüber, dass an diesen Nutzer bereits eine E-Mail gesendet wurde wird neben den üblichen Abschlussbefehlen in der Datenbank gespeichert.
            
            \begin{lstlisting}[language=Python, caption={summary.py(4) - Bestätigungs-Mail} \label{code: summary.py(4)}]
    # trigger confirmation email
    confirmation_mail(first_name, summary, email)
    insert_update(user_id, 'mail_sent', '1')

    # save state to DB
    insert_update(user_id, 'state', states.APPOINTMENT)
    return states.APPOINTMENT
            \end{lstlisting}

                    
        \subsection{confirmation\_mail.py - Bestätigung per E-Mail} \label{Implementierung: confirmation_mail.py}
            Um dem Nutzer die Zusammenfassung in Form einer E-Mail zukommen zu lassen (wie in Listing 6.16 aufgerufen), muss diese zunächst zusammengesetzt werden. Die Bibliotheken \verb|mime| \cite{email.mime} und \verb|smtplib| \cite{smtplib} helfen dabei, eine sichere Verbindung zu einem Mail-Server aufzubauen, über den die fertige E-Mail versenden werden kann.\\

            Erforderliche Zugangsdaten werden außerhalb der Funktion \verb|confirmation_mail| aus den \verb|constants| abgefragt und für die Verwendung innerhalb der Funktion zwischen-gespeichert. So werden diese nicht bei jedem Funktionsaufruf erneut abgerufen.\\
            \\
            Die Funktion bekommt Empfänger-Name sowie -Adresse und die Zusammenfassung aus der Funktion \verb|summary| übergeben. Über die \verb|smtplib| wird ein Server-Objekt erstellt. Gegenüber diesem Server authentifiziert sich der Bot nun via Benutzername und Passwort. War die Authentifizierung erfolgreich, wird die eigentliche Nachricht zusammengesetzt. Dazu benötigt werden vier Bauteile: 
            \begin{enumerate}
                \item Sender-Adresse
                \item Empfänger-Adresse
                \item Betreff
                \item Nachricht
            \end{enumerate}
            Die Nachricht wird zuerst via der Funktion \verb|attache| zusammengesetzt, um dann aus dem vordefinierten String ein \verb|message|-Objekt zu konstruieren. Schließlich kann die E-Mail via \verb|sendmail| unter Verwendung des Mail-Servers versendet werden. Die Verbindung zum Server wieder getrennt.

            \begin{lstlisting}[language=Python, caption={confirmation\_mail.py - Bestätigung und Zusammenfassung für den Nutzer per E-Mail} \label{code: confirmation_mail.py}]
def confirmation_mail(recipient_name, summary, recipient_address):

    # open connection to mail server and authenticate
    server = smtplib.SMTP_SSL(smtp_address, smtp_port)
    server.login(sender_address, password)

    # create multipart object, the email consists of
    message = MIMEMultipart()

    # define from-address, to-address and subject of the email
    message['From'] = sender_address
    message['To'] = recipient_address

    subject = 'Coaching Bot | Confirmation - sign up complete'
    message['Subject'] = subject

    # email body
    body =   f"""Hi {recipient_name}, \t
        thanks for signing up. This is the confirmation for your 
        sign up with the coaching program by wavehoover. \n 
        {summary}\n
        Looking forward to meeting you!\n
        Your wavehoover Team"""
    
    # create the text object for the email
    message.attach(MIMEText(body, 'plain'))

    server.sendmail(message['From'], message['To'], message.as_string())
    server.quit()
            \end{lstlisting}


        \subsection{appointment.py - Kalender-Event erstellen} \label{Implementierung: appointment.py}
            Um einen Termin zu vereinbaren, muss ein kompatibles JSON-File an die Funktion \verb|make_appointment|, die wiederum die Google Calendar API anspricht, formuliert werden. Ziel der Funktion \verb|appointment| ist es also, den Zeitstempel vom Nutzer entgegenzunehmen, das Kalender-Event zu bauen und es zu übergeben. \\
            Dazu fragt sie zunächst alle erforderlichen Informationen bei der Datenbank ab. 

            \begin{lstlisting}[language=Python, caption={appointment.py - DB-Abfrage der zu verbauenden Informationen} \label{code: appointment.py}]
def appointment(update: Update, context: CallbackContext) -> int:

    user_id = update.message.from_user.id
    email = get_value(user_id, 'email')
    telephone = get_value(user_id, 'telephone')
    
    summary = 'wavehoover | Coaching Session'
            \end{lstlisting}
            
            Der erhaltene Zeitstempel für den Beginn des Zeitfensters wird dann in ein Format übersetzt, das die Google Calendar API akzeptiert: \\ 
            \verb/%Y-%m-%dT%H:%M:%S+01:00/ \\
            Das Ende des Zeitfensters wird auf 50 Minuten nach dem Start gesetzt und die beiden korrekt formatierten Zeitstempel in das JSON-Event verbaut.\footnote{Format und Aufbau des Events können via dem Google APIs Explorer getestet werden. \cite{apiExplorer})}

            \begin{lstlisting}[language=Python, caption={appointment.py - Formatierung des Zeitstempels in RFC3339} \label{code: appointment.py}]
    slot_start = update.message.text
    dt_slot_start = datetime.strptime(slot_start, '%Y-%m-%d %H:%M:%S')
    iso_slot_start = str(dt_slot_start.isoformat('T') + '+01:00')

    slot_end = str(dt_slot_start + timedelta(minutes=50))
    dt_slot_end = datetime.strptime(slot_end, '%Y-%m-%d %H:%M:%S')
    iso_slot_end = str(dt_slot_end.isoformat('T') + '+01:00')
            \end{lstlisting}

            \begin{lstlisting}[language=Python, caption={appointment.py - Konstruktion des Kalender-Events} \label{code: appointment.py}]
    # build the event data into the event object
    event = {
        f'summary': summary,
        'location': 'Phone Call',
        'description': f'Your coach will call you 
        under the following number: {telephone}',
        'start': {'dateTime': iso_slot_start,
                  'timeZone': 'Europe/Berlin',},
        'end': {'dateTime': iso_slot_end,
                'timeZone': 'Europe/Berlin',},
        'attendees': [{'email': email},],
        },
        }
            \end{lstlisting}
            
            Ist der Aufruf an die Funktion \verb|make_appointment| abgesetzt und ohne Fehler zurückgekehrt, so wird die Datenbank entsprechend um den Start-Zeitstempfel erweitert und der Nutzer wird informiert. 
            \begin{lstlisting}[language=Python, caption={appointment.py - Konstruktion des Kalender-Events} \label{code: appointment.py}]
            make_appointment(user_id, slot_start, event) # hand over user info to make appointment
            insert_update(user_id, 'appointment', slot_start)
            \end{lstlisting}

            Überspringt der Nutzer diesen letzten Schritt, gibt ihm die Funktion \verb|skip_appointment| lediglich eine Nachricht aus, die die Option offen lässt, auf anderem Weg mit dem Coach in Kontakt zu treten.

        \subsection{status.py - Fortschritt abrufen} \label{Implementierung: status.py}
            Die Funktion \verb|status| ist eine Meta-Funktion und gibt dem Nutzer seinen aktuellen Fortschritt zurück. Dazu prüft die Funktion \verb|status| zunächst, ob der Nutzer überhaupt in der Datenbank existiert. Zwei Szenarien: 
            \begin{enumerate}
                \item Der Bot findet den Nutzer, gibt den aktuellen Status zurück und beendet die Konversation.
                \item Der Bot findet den Nutzer nicht und zeigt dem Nutzer Optionen an, fortzufahren - namentlich die Hilfe aufzurufen oder eine neue Konversation mit dem Bot zu starten.
            \end{enumerate}







    \section{Datenbank} \label{Implementierung: Datenbank}
        In diesem Abschnitt wird die Funktionsweise des Database-Connectors erläutert.  
        Der Database-Connector wird unter der Zuhilfenahme der sqlite3-Bibliothek programmiert, die es ermöglicht, klassische Datenbank-Operationen direkt aus einem Python-Skript heraus anzustoßen und hier als Basis für den Database-Connector dient. Die CRUD-Operationen selbst werden in handelsüblichem SQL formuliert und übergeben. Die Datenbankoperationen sind in separate Funktionen aufgeteilt, die immer an die Struktur aus \ref*{Realisierung: Datenbank} angelehnt sind. Zunächst wird eine Verbindung zur Datenbank geöffnet, es finden Prüfungen statt, eine CRUD-Operaion wird abgesetzt und die Antwort entweder innerhalb der Funktion analysiert und ein \verb|Boolean| oder die übergebenen Daten aufbereitet und im entsprechenden Format zurückgegeben. Alle Funktionen sind ähnlich aufgebaut.
                
        \subsection{create\_db.py - Datenbank und Schema aufbauen}
            Es wird versucht, eine Verbindung zur Datenbank \verb|db| aufzubauen. Ist dies erfolgreich, wird der \verb|cursor| erstellt und geprüft, ob es die Tabelle \verb|users| schon gibt. Ist dem so, wird die Funktion mit einem Commit und dem Schließen der Verbindung zur Datenbank, beendet. \\
            Ist eine der beiden Prüfungen nicht erfolgreich, wird das entsprechende Element neue erstellt. Dabei entspricht das \verb|CREATE|-Statement hier dem Datenbankschema aus Abb. \ref*{fig: data base model}.
            \begin{lstlisting}[language=Python, caption={Database Connector mit sqlite3} \label{code: sqlite3 schema}]
# imports
import sqlite3

db = 'coachingBotDB.db'

# build a new db, if none exists yet
def create_db ():
    # connect to db
    connection = sqlite3.connect(db)
    # cursor
    cursor = connection.cursor()

    # table checker sql statement
    checker = '''SELECT count(name)
        FROM sqlite_master
        WHERE type='table' AND name='users'
    '''

    # table creation sql statement
    table_users = '''CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY,
        time_stamp TEXT,
        first_name TEXT,
        last_name TEXT,
        gender TEXT,
        photo BLOB,
        birthdate INTEGER,
        email TEXT UNIQUE,
        telephone TEXT UNIQUE,
        longitude INTEGER,
        latitude INTEGER,
        bio TEXT,
        state INTEGER,
        mail_sent BOOLEAN,
        appointment TEXT,
        event_id TEXT
    );'''

    cursor.execute(checker)

    #if count is 1, table already exists - else, create it
    if cursor.fetchone()[0]==1:
        print('Table already exists.')
    else:
        cursor.execute(table_users)
        print('Table created.')

    connection.commit()
    connection.close()
                \end{lstlisting}


        \subsection{select\_db.py - Nutzerdaten abfragen} \label{Implementierung: select_db.py}
            Hier wird kurz beispielhaft auf die beiden wichtigsten READ-Funktionen des Database-Connectors hingewiesen und wo sie verwendet werden: \\
            \\
            Die Funktion \verb|user-search| bekommt eine Nutzer-ID übergeben und prüft, ob ein Nutzer in der Datenbank existiert. Falls ja, wird \verb|True| zurückgegeben - ansonsten \verb|False|. Die Funktion wird in der Funktion \verb|start| genutzt (siehe \ref*{code: start.py(1)}), wenn geprüft wird, ob ein Nutzer bereits bekannt ist.\\ 
            \\
            Der Funktion \verb|get_value| werden eine Nutzer-ID sowie eine Spaltenbezeichnung übergeben. So kann ein spezifischer Wert aus der Datenbank abgerufen werden. (Die meisten Handler-Funktionen bedienen sich dieser Funktion, um mit Informationen über den Nutzer zu arbeiten.) 
                \begin{lstlisting}[language=Python, caption={select\_db.py - Datenbankabfrage einzelner Nutzerinformationen} \label{code: select_db.py}]
# get a specific value of a user
def get_value(user_id, column):
    ...

    selection = f"""SELECT {column}
        FROM users
        WHERE user_id = {user_id}
        """

    # execute command to fetch all data from table users
    cursor.execute(selection)

    # store all data from selection in table_data
    table_value = (str(cursor.fetchone())).lstrip("('").rstrip("',)")
    return table_value
                \end{lstlisting}

        \subsection{insert\_value\_db.py - Werte schreiben} \label{Implementierung: insert_value_db.py}
            Um sicherzustellen, dass eine Datebank existiert, wird zunächst die Funktion \verb|create_db| aufgerufen. Diese kommt schnell zurück, da die Datenbank in den meisten Fällen bereits existiert. Nun wird in einem \verb|try/except|-Block versucht (siehe Listing 6.24), einen existierenden Datenbankeintrag zu aktualisieren. Das funktioniert meistens, weil der Datensatz für einen Nutzer bereits bei der Eingabe von \verb|/start| durchgeführt wird. So kann ein Eintrag bereits von Beginn an immer weiter angereichert werden.

            \begin{lstlisting}[language=Python, caption={select\_db.py - Datensatz eines Nutzers anreichern} \label{code: insert_value_db.py}]
    ...

    try:
        cursor.execute('INSERT INTO users (user_id) VALUES (?)', (user_id,))
        logger.info (f'+++++ CREATED record {user_id}: {cursor.lastrowid} +++++')
    except sqlite3.IntegrityError:
        logger.info("+++++ FOUND record... UPDATING... +++++")

    # sql command to UPDATE an existing record
    update_command = f"UPDATE users SET {column} = ? WHERE user_id = ?"
    update_args = (value, user_id)

    cursor.execute(update_command, update_args)

    ...

            \end{lstlisting}
        
        \subsection{delete\_record.py} \label{Implementierung: delete_record.py}
            Die Funktion \verb|delete_record| bekommt eine Nutzer-ID übergeben und prüft zunächst via der Funktion \verb|user_search|, ob es den Nutzer mit der angegebenen Nutzer-ID gibt. Falls ja, wird in einem \verb|try/except|-Block versucht, alle Informationen eines Nutzers via SQL-Befehl zu löschen.\footnote{Die Funktion delete\_value ist mit der Funktion delete\_record fast identisch. Hier wird aber zusätzlich eine Spaltenbezeichnung übergeben, die es ermöglicht, nur einen einzelnen Wert zu löschen.} Die Funktion wird in den Funktionen \verb|cancel| und \verb|delete| aufgerufen.











    \section{Terminvereinbarung mit dem Google Calendar} \label{Implementierung: Kalender} 
        
        \label{Implementierung: calendar_manager.py}
        Um die Anforderungen aus der Realisierung in Abschnitt \ref*{Realisierung: calendar} zu erfüllen, ergo mit der Google Calendar API zu kommunizieren, sind die Schritte aus Kapitel \ref*{Grundlagen} Grundlagen, Abschnitt \ref*{Grundlagen: Google Calendar API} Google Calendar API durchzuführen. Der Kalender-Manager basiert auf der \verb|quickstart.py| und erweitert diese. Daneben nutzt der Kalender-Manager Pythons native Bibliothek zum Zusammenfügen von Dateipfaden (path) und den soeben beschriebenen Database-Connector. Er erlaubt es dem aufrufenden System, abzufragen, ob eine Zeitspanne in einem bestimmten Kalender verfügbar ist und Termine zwischen einer festgelegten Veranstalter-Adresse und beliebig vielen Teilnehmer-Adressen zu erstellen und zu versenden. Im Folgenden werden Aufbau und Funktionsweise der \verb|calendar_manager.py| erklärt: \\ 
        \\
        Die \verb|main|-Funktion des Kalender-Managers authentifiziert sich gegenüber der Google Calendar API und versucht daraufhin, die nächsten zehn Elemente des Kalenders auszugeben. Ist die Authentifizierung nicht erfolgreich, wird ein \verb|HTTP|-Error ausgegeben.  \\
        Die \verb|authenticate| ist eine reduzierte Version der \verb|main|. Sie gibt ein \verb|service|-Objekt zurück, das genutzt werden kann, um die Funktionen der Google Calendar API anzusprechen und auszuführen.\\
        
        \subsection{Zeitspanne prüfen}
            Die Funktion \verb|check_availability| nimmt einen Start- und einen Endzeitpunkt entgegen und prüft die Verfügbarkeit des entsprechenden Kalenders. Sie gibt einen \verb|BOOLEAN| zurück, der aussagt, ob der Termin noch frei ist. Dafür werden die beiden Zeitstempel so formatiert, dass sie dem RFC3339-Format entsprechen. Das Format setzt sich zusammen wie folgt: \\
            \\
            YYYY-MM-DD, \glq T\grq, HH:MM:SS.ms, Buchstabe \glq Z\grq \\
            \\
            Beispiel für 10:05 Uhr vormittags am 28.02.2022, koordinierte Weltzeit (UTC): \\
            \\
            \verb/2022-02-28T10:05:00.00Z/ \\
            \\
            Weitere Informationen zum RFC3339-Format finden sich im offiziellen Standard. \cite{date_time} \\
            
            Die beiden Zeitstempel werden in eine \verb|JSON|-Anfrage eingebaut:
            \begin{lstlisting}[language=Python, caption={check\_availability - Komposition der Anfrage an die API} \label{code: check_availability(1)}]
def check_availability(start, end):

    service = authenticate()
    start_iso = str(start.isoformat('T')+'+01:00') # convert UTC to CET
    end_iso = str(end.isoformat('T')+'+01:00') # same for end time
    request = {
        "timeMin": start_iso,
        "timeMax": end_iso,
        "timeZone": "Europe/Berlin", 
        "items": [
            {
            "id": coaching_calendar_ID
            }]
        }
            \end{lstlisting}

            In einem \verb|try/except|-Block wird das die Anfrage dann an die API-Funktion \verb|freebusy| übergeben. Ist dies erfolgreich, gibt die API eine Antwort im \verb|JSON|-Format zurück, das Python als Dictionary interpretieren und in mehreren genesteten Schleifen auslesen kann. Ist das Feld \verb|busy: []| leer, so ist das Zeitfenster frei. Es wird \verb|True| zurückgegeben. Ist das Feld nicht leer, gibt es einen Terminkonflikt. Die Funktion gibt \verb|False| zurück. \\
            Erzeugt dieser Vorgang einen Fehler, wird ein \verb|HTTP|-Error auf der Konsole ausgegeben. \\

            \begin{lstlisting}[language=Python, caption={check\_availability - Versant der Anfrage und Analyse der Antwort der API} \label{code: check_availability(2)}]
    try:
        response = service.freebusy().query(body=request).execute()    
        # climb down the dict latter and read the busy response from HTTP-Response
        calendars = response.get('calendars')
        calendar_temp = calendars.get(coaching_calendar_ID)
        availability = calendar_temp.get('busy')
        if availability == []:
            return True

    except HttpError as error:
        logger.info('ERROR: %s' % error)
                    \end{lstlisting}




        \subsection{Terminvorschläge generieren}
            Dem Nutzer sollen drei Terminvorschläge gemacht werden. Die Funktion \verb|find_slots| sucht folgendermaßen nach drei verfügbaren Zeitfenstern und gibt diese in Form einer Liste zurück: 
            
                Die Suche für Termine startet um 08:00 Uhr am kommenden Arbeitstag. Es wird zwischen heute und morgen 08:00 Uhr unterschieden. Liegt der Zeitstempel zur Zeit der Ausführung der Funktion vor 08:00 Uhr, so wird die Suche heute um 08:00 Uhr begonnen. Ist es bereits nach 08:00 Uhr, so wird die Suche am nächsten Tag begonnen. Das Resultat ist der Zeitstempel von heute oder morgen 08:00 Uhr, der als Startzeit für die Suche verwendet wird.

            \begin{lstlisting}[language=Python, caption={find\_slots - Sucht drei Terminvorschläge heraus} \label{code: find_slots}]
def find_slots():

    # Get today's datetime
    datenow = datetime.datetime.now()
    # Create datetime variable for 8 AM
    dt8 = None
    # If today's hour is < 8 AM
    if datenow.hour < 8:

        # Create date object for today's year, month, day at 8 AM
        dt8 = datetime.datetime(datenow.year, datenow.month, datenow.day, 8, 0, 0, 0)

    # If today is past 8 AM, increment date by 1 day
    else:
        # Get 1 day duration to add
        day = datetime.timedelta(days=1)
        # Generate tomorrow's datetime
        tomorrow = datenow + day

        # Create new datetime object using tomorrow's year, month, day at 8 AM
        dt8 = datetime.datetime(tomorrow.year, tomorrow.month, tomorrow.day, 8, 0, 0, 0)
            \end{lstlisting}

            Nun wird die Google Calendar API für das erste Zeitfenster abgefragt. Ist das Fenster frei, übernimmt die Funktion den Slot und fährt mit der Suche fort. Der nächste Termin wird drei Tage später gesucht, um mehrere unterschiedliche Termine anbieten zu können. Ist ein Fenster belegt, so wird der Slot zur nächsten vollen Stunde geprüft und dies solange, bis drei Termine gefunden sind. Neben der Rückgabe als Liste erfolgt eine Ausgabe auf der Konsole.

            \begin{lstlisting}[language=Python, caption={find\_slots - Sucht drei Terminvorschläge heraus} \label{code: find_slots}]
    # within the business hours, find 3 free time slots to suggest to the user
    free_slots = []
    slots = 0
    start = dt8
    round = 0
    while slots < 3:
        round += 1
        end = start + datetime.timedelta(minutes=50)
        
        if (check_availability(start, end)): 
            free_slots.append(str(start))
            slots += 1;
            start = dt8 + datetime.timedelta(days=3*slots)

        else: 
            start = start + datetime.timedelta(hours=1)
        
    return free_slots
            \end{lstlisting}
            Wochenenden und Zeiten vor 08:00 sowie nach 18:00 Uhr werden übersprungen, da die Funktion \verb|check_availability| für diese Zeiten immer \verb|False| zurückgibt.\footnote{Welche Zeiten als busy zurückgegeben werden kann einfach im eigenen Kalender-Client angepasst werden. Eine Anpassung im Code ist nicht erforderlich.}


        \subsection{make\_appointment - Finalen Termin vereinbaren}
            Abschließend kann der Nutzer einen der drei Vorschläge auswählen. Der gewählte Vorschlag wird an die Funktion \verb|make_appointment| übergeben inkl. der Kalender-ID an die API via der API-Funktion \verb|insert| übergeben und so in den entsprechenden Kalender eingefügt. 

            \begin{lstlisting}[language=Python, caption={make\_appointment - Terminvereinbarung und Erstellung Kalender Event in Google Calendar} \label{code: make_appointment}]
def make_appointment(event):
    service = authenticate()
    try:
        service.events().insert(calendarId=coaching_calendar_ID, body=event).execute()

    except HttpError as error:
        logger.info('ERROR: %s' % error)
            \end{lstlisting}
            Google versendet eine Termineinladung, in der die Informationen enthalten, sind, die im Event mitgeschickt wurden und der Nutzer sowie der Coaching-Kalender bekommen eine entsprechende Einladung. Falls bei dieser Operation ein Fehler auftritt, wird ein \verb|HTTP|-Error auf der Konsole ausgegeben.

    
    \section{Web-GUI}
        Die Web-GUI stellt dem Coach eine Liste der Nutzer, die den Prozess begonnen haben zur Verfügung und zeigt den aus den Anmeldungen resultierenden Terminkalender an. Die GUI wurde mit Flask erstellt und bindet Daten aus der Datenbank, Nutzerbilder, eine Google Calendar View zusammen auf eine HTML-Seite, die mithilfe von CSS gestyled wird.
        
        Die \verb|app.py| instanziiert via der Flask Bibliothek einen Webserver und konstruiert den darzustellenden Inhalt in Form eines Templates. Dieses wird aus Nutzerinformationen zusammengesetzt, die bei Aufrufen der entsprechenden URL aus der Datenbank abgefragt werden sowie aus den von Nutzern eingereichten Bildern. 
        Das fertige Template wird dann an den Webserver zurückgegeben, der die Oberfläche an den Web-Browser liefert.

        \begin{lstlisting}
# Instantiate Flask App / Build Web Server to display GUI
app = Flask(__name__)
app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 0

@app.route("/")
def home():
    data = get_customers()
    picture_path = os.path.join('static', 'user_pictures')
    return render_template('home.html', **config.CONTEXT, customers=data, path=picture_path)
        \end{lstlisting}

        Die \verb|home.html| besteht aus drei Teilen. Zunächst wird eine Tabelle erstellt und mit den für die Darstellung der Daten aus der Datenbank erforderlichen Spalten versehen. Daraufhin werden die Daten aus der Datenabank, die eine andere Spaltenreihenfolge haben, als die, in der sie hier dargestellt werden sollen, den entsprechenden Spalten zugeordnet.
        Schließlich wird eine Google Calendar View via iframe eingebunden.Die Ansicht aktualisiert sich auf Anfrage. \\
        Es kommt ein minimalistisches CSS-Template zum Einsatz, das den Ansprüchen, Nutzerdaten einzusehen leicht genügt.\\ \\

        Über die IP-Adresse \verb|127.0.0.1| und Port \verb|5000| ist die GUI als Admin zu erreichen\footnote{Um das Kalender-Feature einsehen zu können, ist eine Anmeldung mit dem entsprechenden Google-Konto erforderlich.}: \url{http://127.0.0.1:5000/} \\ \\ \\


    Damit ist das Kapitel \ref*{Implementierung} Implementierung abgeschlossen. Es folgt ein Beispieldurchlauf.


    % \section{Tests}
    %         Das Haupt-Test-Instrument ist die Telegram-App selbst. Daneben wurden 2 Testskripte zum einfachen Testen verschiedener Teile der App geschrieben. Tests sind getrennt und entsprechend ein- oder auskommentiert. 