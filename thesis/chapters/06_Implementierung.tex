\label{Implementierung}
\chapter{Implementierung}

    Die im Kapitel \ref*{Realisierung} Realisierung erarbeiteten Ansätze wurden umgesetzt. Die Systeme und Ergebnisse werden im Folgenden beschrieben.

    \section{main.py - Anmeldung, Updater, Dispatcher und Handler-Konfiguration} \label{main.py}
        Die \verb|main.py|-Methode basiert auf dem im Kapiel \ref*{Grundlagen} Grundlagen vorgestellten Conversation Bot. Sie importiert alle Zustands-Funktionen (siehe \ref*{Implementierung: Handler Functions} Handler Functions), authentifiziert sich durch den entsprechenden API-Schlüssel (Token) gegenüber der Telegram API und beinhaltet den Dispatcher. 
        
        \begin{lstlisting}[language=Python, caption={bot/main.py - Authentifizierung und Schlüssel-Übergabe an den Updater}\label{code: bot/main.py 1}]
# Hand over API_TOKEN to the bot
bot = telegram.Bot(token=API_KEY)

def main() -> None:
    # Creates the updater and passes the API_TOKEN to it.
    updater = Updater(API_KEY)
        \end{lstlisting}
        
        \subsection{Dispatcher} \label{Implementierung: Dispatcher}
            Dispatcher liefern Nachrichten an den User aus. Pro Bot gibt es grundsätzlich mind. einen Dispatcher. Der Coaching Bot hat aber mehrere für mehrere Konversationsstränge. An den Dispatcher werden Conversation- sowie CommandHandler gebunden und konfiguriert.
    
        \subsection{Conversation-Handlers} \label{Implementierung: Conversation-Handlers}
            Der Conversation-Handler bildet die in Abb. \ref*{fig: state machine} konzipierte State Machine ab. Als solche, kontrolliert er den Konversationsfluss zwischen dem User und dem Bot. Pro Bot kann es mehrere Conversation-Handler geben. Der CoachingBot hat aber nur Einen: den \verb|conv_handler|. Der Conversation-Handler koordiniert alle im Haupt-Konversationsfluss enthaltenen Command-Handler.
    
        \subsection{Command-Handler} \label{Implementierung: Command-Handler}
            Pro Zustand aus der State Machine gibt es einen Command-Handler. Für jeden Command-Handler gibt es ein Set an Kriterien und / oder einen Befehl, der die zugeordnete Zustands-Funktion auslöst. i.e. den Befehl \verb|/start| für die Funktion \verb|start| aus \verb|start.py| im gleichnamigen Command-Handler, der hier als Einstiegspunkt definiert ist. Funktionen werden nur mittelbar vom Nutzer und unmittelbar von der State-Machine ausgelöst.

        \subsection{Message-Handler} \label{Implementierung: Message-Handler}
            Befehle werden vom Nutzer eingegeben und vom Message-Handler entgegengenommen. Ein Message-Handler prüft die Eingabe eines Nutzers auf vordefinierte Kriterien und meldet das Ergebnis an den Conversation-Handler.

        \begin{lstlisting}[language=Python, caption={bot/main.py - Dispatcher, Conversation- \& Command-Handler}\label{code: bot/main.py 2}]
    # Gets the dispatcher to register handlers
    dispatcher = updater.dispatcher
    
    # bot state machine and main conversation handler
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start)],
        states={
            states.BIO:         [MessageHandler
                (Filters.text& ~Filters.command, bio), 
                CommandHandler('skip', skip_bio)],
            states.GENDER:      [MessageHandler
                (Filters.regex('^(Gentleman|Lady|Unicorn)$'),gender), 
                CommandHandler('skip', skip_gender)],
            states.BIRTHDATE:   [MessageHandler
                (Filters.text& ~Filters.command, birthdate), 
                CommandHandler('skip', skip_birthdate)],
            states.EMAIL:       [MessageHandler
                (Filters.text& ~Filters.command, email), 
                CommandHandler('skip', skip_email)],
            states.TELEPHONE:   [MessageHandler
                (Filters.text& ~Filters.command, telephone), 
                CommandHandler('skip', skip_telephone)],
            states.LOCATION:    [MessageHandler
                (Filters.location& ~Filters.command, location), 
                CommandHandler('skip', skip_location)],
            states.PHOTO:       [MessageHandler
                (Filters.photo   & ~Filters.command, photo), 
                CommandHandler('skip', skip_photo)],
            states.SUMMARY:     [MessageHandler
                (Filters.regex('^(COMPLETE SIGN UP)$'),  summary)],
            states.APPOINTMENT: [MessageHandler
                (Filters.text& ~Filters.command, appointment), 
                CommandHandler('skip', skip_appointment)],
            # more states here...
            },
            fallbacks = [CommandHandler('cancel', cancel)],
    )

    dispatcher.add_handler(conv_handler)
    # more conversation handlers for secondary commands
    dispatcher.add_handler(CommandHandler('summary', summary))
    dispatcher.add_handler(CommandHandler('delete', delete))
    dispatcher.add_handler(CommandHandler('status', status))
        \end{lstlisting}

        Über die folgenden Befehle, werden die entsprechenden, gleichnamigen Command-Handler und Funktionen aus \ref*{code: bot/main.py 2} ausgelöst. 

        \begin{itemize}
            \item \verb|/start| - startet den Konversationsfluss. Der in dieser Applikation umfangreichste Conversation-Handler umfasst zwei Befehle: \verb|/start| und \verb|/cancel|. Solange der Bot ausgeführt wird, lässt sich ein Konversationsfluss mit ihm über den Befehl \verb|/start| starten und via \verb|/cancel| beenden.
            \item \verb|/cancel| - beendet den Konversationsfluss, löscht Nutzerdaten aus der Datenbank und informiert entsprechend
            \item \verb|/delete| - löscht Nutzerdaten des Nutzers und informiert ihn
            \item \verb|/help| - gibt die Hilfe aus
            \item \verb|/summary| - gibt die Zusammenfassung für den Nutzer aus
            \item \verb|/status| - gibt gibt den aktuellen Fortschritt für den Nutzer aus
        \end{itemize}
        (Zur Funktionsweise der den Befehlen zugeordneten Zustands-Funktionen siehe den entsprechden Abschnitt unter \ref{Implementierung: Handler Functions}.) \\ \\
        
        Schließlich wird die State Machine des Coaching Bots gestartet. Über das sog. Polling werden Aktualisierungen konstant von Telegram nachgeladen. Der Bot ist aktiv (idle) und wartet darauf, Befehle entgegenzunehmen.
        \begin{lstlisting}[language=Python, caption={bot/main.py - Start Polling \ Idle}\label{code: bot/main.py 3}]
    # Start the Bot
    updater.start_polling()

    updater.idle()
        \end{lstlisting}


    \section{Zustands-Funktionen: Handler Funktions} \label{Implementierung: Handler Functions}
        Handler-Funktionen\footnote{siehe coaching\_bot/handler\_functions unter \url{https://github.com/mwel/coaching_bot/tree/main/bot/handler_functions}} sind Funktionen, die auf Eingaben reagieren, die via CallbackContext vom User an den Bot gesendet werden und bestimmten Kriterien entsprechen. Diese Kriterien werden direkt in der main.py in einem der CommandHandler definiert. \\
        \\
        Im Folgenden gehen wir detailliert auf die einzelnen Handler-Funktionen ein, beschreiben deren Umfang und Aufbau und erklären ihre Funktionsweise. 

        \subsection{start.py} \label{Implementierung: start.py}

        \begin{lstlisting}[language=Python, caption={start.py - Start-Funktion und Einstieg in den Konversationsfluss}\label{code: start.py}]
def start(update: Update, context: CallbackContext) -> int:
    # CREATE DB, IF NOT EXISTS
    create_db()

    user_id = update.message.from_user.id

    user_exists = select_db.user_search(user_id)
    if user_exists:
        # get user's state from db
        state = int(select_db.get_value(user_id, 'state'))

        update.message.reply_text(
            f'Welcome back {update.message.from_user.first_name},\n'
            'Let\'s continue where we left off...',
            reply_markup=ReplyKeyboardRemove(),
            )

        if state == states.SUMMARY:  
        # sign up was apparently already completed for this user
            reply_keyboard = [
                ['/status'], 
                ['/summary'],
                ['/delete']]
            update.message.reply_text(
            'Ah! I see, you have already completed 
            the sign up.\nYou now have multiple options below:\n'
            'If you have not made an appointment yet 
            and would like to do so, enter /summary.\n\n'
            'If you want to /delete your record entirely, 
            press /delete.',
            reply_markup=ReplyKeyboardMarkup(
            reply_keyboard, one_time_keyboard=True, 
            input_field_placeholder='SIGN UP COMPLETE'
                )
            )

        elif state == states.APPOINTMENT and select_db.get_value(user_id, 'appointment') == 'None':
            reply_keyboard = [
                ['/status'], 
                ['/delete']]
            update.message.reply_text(
            'If you have not made an appointment yet 
            and would like to do so, enter /summary.\n\n',
            reply_markup=ReplyKeyboardMarkup(
            reply_keyboard, one_time_keyboard=True, 
            input_field_placeholder='SIGN UP COMPLETE'
            )
        )
            return ConversationHandler.END

        elif state == states.APPOINTMENT:
            appointment_made = select_db.get_value(user_id, 
            'appointment')
            reply_keyboard = [
                ['/status'], 
                ['/delete']]
            update.message.reply_text(
            f'Cool. You already have an appointment on 
            {appointment_made} \n\n'
            'In case you would like to cancel, 
            you can do that via your calendar app.\n\n'
            'Otherwise, we are looking forward to our call.',
            reply_markup=ReplyKeyboardMarkup(
            reply_keyboard, one_time_keyboard=True, 
            input_field_placeholder='SIGN UP COMPLETE'
            )
        )
            return ConversationHandler.END
        
        # call next function for user
        update.message.reply_text(states.MESSAGES[state], reply_markup=states.KEYBOARD_MARKUPS[state])
        return state

    logger.info(f'+++++ NEW USER: {update.message.from_user.first_name} 
    {update.message.from_user.last_name} +++++')

    # write user info to db
    insert_update(user_id, 'first_name', update.message.from_user.first_name) 
    insert_update(user_id, 'last_name', update.message.from_user.last_name)
    insert_update(user_id, 'appointment', 'None')
    insert_update(user_id, 'event_id', '0')

    update.message.reply_text(
        f'Hi {update.message.from_user.first_name},\n'
        'I am a coaching bot by wavehoover. You have 
        taken the first step on your journey to success 
        by contacting me. I will guide you through the 
        application process for your first coaching session. '
        'It\'s super easy. Just follow the questions, answer 
        or skip them - that\'s it.\n\n'
        '[You can send /cancel at any time, if you are 
        no longer interested in a conversation.]\n\n'
        f'Now, {update.message.from_user.first_name} - 
        {states.MESSAGES[states.BIO]}',
        reply_markup=ReplyKeyboardRemove(),
        )

    # save state to DB
    insert_update(user_id, 'time_stamp', datetime.now())
    insert_update(user_id, 'state', states.BIO)
    return states.BIO
        \end{lstlisting}

            Die Methode \verb|start| in der \verb|start.py| fungiert als Eingangstor für jeden User. Wann immer der Befehl \verb|/start| an den Bot schickt wird, löst der CommandHandler die Methode \verb|start| aus.\\
            \\
            Zunächst wird geprüft, ob es eine Datenbank gibt. Ist dies der Fall, wird geprüft, ob der Nutzer, der die Methode ausgelöst hat, bereits in der Datenbank existiert. \\
            \\
            Ist dies der Fall, gibt die Methode eine Willkommen-zurück-Nachricht aus und differenziert zwischen unterschiedlichen Reaktionen auf unterschiedliche Zustände:
            \begin{enumerate}
                \item Befindet der Nutzer sich im Zustand \verb|SUMMARY|, hat also bereits alle Fragen beantwortet, aber noch keinen Termin vereinbart, so werden in diesem Zustand sinnvolle Optionen empfohlen. Der Nutzer kann sich den Status seiner Bewerbung ausgeben lassen, die Zusammenfassung erneut beantragen oder alle seine Daten löschen.
                \item Befindet der Nutzer sich im Zustand \verb|APPOINTMENT|, hat aber noch keinen Termin vereinbart, die Zusammenfassun aber bereits erhalten, erhält er zusätzlich zur Option, sich die Zusammenfassung erneut ausgeben zu lassen und so die Terminfindung zu starten, nur die Status- und Lösch-Optionen. Natürlich kann der Nutzer auch manuell alle Befehle jederzeit eingeben, aber die Tastatur ist so für Optionen vordefiniert, dass der Nutzer in eine bestimmte Richtung gelenkt wird. Nach der Ausgabe dieser Nachricht, beendet der ConversationHandler die Kommunikation.
                \item Befindet der Nutzer sich im Zustand \verb|APPOINTMENT| und hat bereits einen Termin vereinbart, so werden Informationen zu dem Termin aus der Datenbank abgerufen und direkt ausgegeben. Auch in diesem Fall wird die Konversation nun beendet, da keine weiteren Interaktionen mit dem Nutzer vorgesehen sind.
            \end{enumerate}

            Egal welche Option die Methode wählt, der Nutzer wird immer in den Konversationsfluss zurückgeführt und zwar genau vor der Frage, die zuletzt nicht beantwortet wurde. Eine Frage zu überspringen gilt dabei auch als Beantwortung. Dazu wird die Datenbank abgefragt und der Wert aus \verb|state| für die entsprechende User-ID an den ConversationHandler weitergegeben. Dieser präsentiert als Antwort darauf die nächste Frage im Konversationsfluss. \\
            \\
            Treffen all diese Konditionen nicht zu, wurde der Nutzer also nicht in der Datenbank gefunden, so startet der Bot ganz normal mit einer Begrüßung, nachdem initiale Daten von der Telegram-Instanz des Nutzers abgefragt und in die Datenbank geschrieben wurden. \\
            \\
            Ist die Nachricht an den Nutzer ausgeliefert, aktualisiert der Bot den Zustand für den Nutzer in der Datenbank, damit der Bot weiß, welche Fragen der Nutzer schon beantwortet hat und er den Nutzer bei einer Rückkehr wieder am richtigen Punkt in den Konversationsfluss einfügen kann.\\
            \\    
            Bevor der Bot den Nutzer zur nächsten Stufe weiterleitet, speichert er noch einen Zeitstempel, damit man nachvollziehen kann, wann der Nutzer seinen Prozess begonnen hat.


        \subsection{bio.py} \label{Implementierung: bio.py}
            %\subsubsection{Methode bio}
                Die Methode \verb|bio| in der \verb|bio.py| speichert die Text-Eingabe eines Nutzers als erste Nutzereingabe nach dem \verb|/start|-Befehl. Sie repräsentiert besonders gut den Aufbau der Handler-Funktionen, weil sie über das Speichern und weiterleiten keine weiteren Features besitzt. Daher erläutern wir den Aufbau der Handler-Funktionen beispielhaft anhand der Methode \verb|bio| für alle anderen Handler-Funktionen:

                \begin{lstlisting}[language=Python, caption={bio.py - Beispiel 1 Handler Function}\label{code: bio.py}]
# Stores the information received and continues on to the next state
def bio(update: Update, context: CallbackContext) -> int:
    
    user_id = update.message.from_user.id
    bio_message = update.message.text
    
    logger.info(f'+++++ Bio of user {user_id}: {bio_message} +++++')

    # write bio to DB
    insert_update(user_id, 'bio', bio_message)

    # reply keyboard for next state
    update.message.reply_text(
        'What a story! We will definately pick that up 
            in our first session!\n\n' + \
        'Ok - now let\'s get some basics down: \n' + \
        states.MESSAGES[states.GENDER],
        reply_markup=states.KEYBOARD_MARKUPS[states.GENDER],
        )

    # save state to DB
    insert_update(user_id, 'state', states.GENDER)
    return states.GENDER
                    \end{lstlisting}

                Zunächst werden ein Update- und ein CallbackContext-Objekt an die Handler-Methode übergeben. Zurückgegeben wird der Datentyp \verb|int|, da die State-Machine am Ende der Methode wissen muss, in welchen Zustand der Nutzer als nächstes geschickt werden soll. \\
                Innerhalb der Methode werden \verb|user_id| und \verb|bio_message| aus dem Update-Objekt gespeichert, da man diese beiden informationen gleich weiterverwenden möchte. Die \verb|bio_message| ist in diesem Fall die Text-Eingabe, die an den Bot nach der letzten Stufe (\verb|start|) übermittelt wurde. Die \verb|user_id| ist die Telegram-ID des jeweiligen Nutzers. \\
                Nach der Ausgabe eines einfachen Log-Eintrags dazu, welcher Nutzer gerade welche Nachricht gesendet hat, wird der Datenbankeintrag des Nutzers um die soeben empfangene Nachricht erweitert. (Funktionalität der \verb|insert_update| Methode folgt unter Abschnitt \ref{Implementierung: insert_update_db.py} insert\_update.py)
                Nun kann die für den Nutzer sichtbare Reaktion auf die Nachricht erfolgen. Die Methode \verb|update.message.reply_text| erlaubt es uns, dem Nutzer einen beliebigen String sowie eine für diese Nachricht individuelles Antwort-Tastatur auszugeben. Die zu übergebenden Parameter sind für die meisten reply\_text-Instanzen in der \verb|states.py| zentral gespeichert, um sich innerhalb der einzelnen Handler-Funktion soweit als möglich von Inhalten zu abstrahieren.\\
                Ist die Ausgabe an den Nutzer erfolgt, bleibt noch die Aktualisirung des Zustands des Nutzers in der Datenbank, gefolgt von der Übergabe des nächsten Zustands an den ConversationHandler.

                Der Aufbau aller weiteren Handler-Funktionen ähnelt der Methode \verb|bio| sehr stark. Auf Erweiterungen und Anpassungen wird in den entsprechenden Abschnitten eingegangen. Die Methode leitet in den Zustand \verb|GENDER|.

            %\subsubsection{Methode skip\_bio}
                Die Methode \verb|skip_bio| in der \verb|bio.py| wird durch den Befehl \verb|/skip| ausgelöst. Dieser Befehl ist in jedem Zustand spezifisch für den CommandHandler einer Stufe definiert und hat in jedem Zustand einen anderen Effekt. In diesem Fall, wird die Methode \verb|skip_bio| aus der \verb|bio.py| aufgerufen. Auch für die Methode \verb|skip_bio| gilt, dass sie den Aufbau der \verb|skip|-Methoden gut repräsentiert. Daher auch hier wieder eine detaillierte Erklärung:

                \begin{lstlisting}[language=Python, caption={skip\_bio.py - Beispiel 2 Handler Function}\label{code: skip_bio.py}]
# Skips this information and continues on to the next state
def skip_bio(update: Update, context: CallbackContext) -> int:
    
    user_id = update.message.from_user.id

    logger.info(f'00000 No bio submitted by {user_id} 00000')

    # alternative message
    update.message.reply_text(
        'Alright. No problem. I know, 
        it can be uneasy to share at first. 
        If you would like, I can offer you a free 
        "gettin to know each other" phone call once 
        you have finished the sign up.',
        reply_markup=ReplyKeyboardRemove(),
        )

    # reply keyboard for next state
    update.message.reply_text(
        states.MESSAGES[states.GENDER],
        reply_markup=states.KEYBOARD_MARKUPS[states.GENDER],
        )    

    # save state to DB
    insert_update(user_id, 'state', states.GENDER)
    return states.GENDER
                \end{lstlisting}


                Der Aufbau ähnelt der \verb|bio|-Methode. Allerdings liegt hier ein reduzierter Umfang und natürlich eine andere Nachricht an den Nutzer vor. So gibt der \verb|Logger| nur aus, dass keine Nachricht eingegangen ist. Ein Update der Datenbank fällt weg, da der Nutzer keine neuen Informationen angegeben hat. Hier werden zwei \verb|reply_text|-Methoden verwendet. \\
                Die Erste dient dazu, eine auf diese \verb|skip|-Methode individuelle Nachricht zu übermitteln. \\
                Die Zweite ähnelt der Methode aus der \verb|bio|-Funktion. Sie übermittelt die Aufforderung zur Eingabe der Information für die nächste Stufe und zeigt die entsprechende Tastatur an. Der Rest der Methode gleicht ihrer Schwester.


        \subsection{gender.py} \label{Implementierung: gender.py}
            %\subsubsection{Methode gender}
                Die einzige Besonderheit der \verb|gender|-Methode aus \verb|gender.py| liegt in der Differenzierung der Datenbankoperationen, die als Resultat der vordefinierten Antwort des Nutzers ausgelöst werden. Die Optionen \glqq Gentleman\grqq, \glqq Lady\grqq und \glqq Unicorn\grqq resultieren in einem nüchternen Datenbankeintrag: \verb|male|, \verb|female|, \verb|diverse|. Die Methode leitet in den Zustand \verb|BIRTHDAY|.
            
            %\subsubsection{Methode skip\_gender}
                %Keine Besonderheiten. 
        

        \subsection{birthdate.py} \label{Implementierung: birthdate.py}
            %\subsubsection{Methode birthdate}
                Der Bot arbeitet in der Methode \verb|birthdate| erstmals mit Input-Validierung. (siehe \ref{Implementierung: validation.py} validation.py) Dazu wird die Nutzereingabe zunächst an die Methode \verb|validate_birthdate| übergeben und auf die Bewertung des Inputs gewartet. Entspricht der Input dem prädefinierten Format, fährt der Bot wie gewöhnlich fort und übergibt den nächsten Zustand zurück an den ConversationHandler. Ist dies jedoch nicht der Fall, so wird eine entsprechende Nachricht an den Nutzer ausgegeben. Da der ConversationHandler erst dann zur nächsten Stufe geht, wenn er von der Methode \verb|birthdate| den entsprechenden Zustand zurückerhalten hat, entsteht hier ein loop, der entweder durch eine gültige Eingabe oder eine der Meta-Funktionen gebrochen werden kann.
        
        
        \subsection{email.py} \label{Implementierung: email.py}
            %\subsubsection{Methode email}
                Wie die \verb|birthdate| auch schon, nutzt die Methode \verb|email| Input-Validation - dieses Mal, um zu prüfen, ob eine gültige E-Mail-Adresse eingegeben wurde. (siehe \ref{Implementierung: validation.py} validation.py)

            %\subsubsection{Methode skip\_email}
                Die Methode \verb|skip_email| ist die einzige Methode, die nicht übersprungen werden kann. Ohne eine gültige E-Mail-Adresse des Nutzers können wichtige Folgefunktionen des Bots nicht genutzt werden und der Sinn und Zweck (eine Terminvereinbarung) ist nicht möglich. Daher ist die Methode \verb|skip_email| so gestaltet, dass sie keinen Zustand zurückgibt, sondern den Nutzer im aktuellen Zustand belässt, bis dieser entweder eine gültige Adresse eingegeben oder einen alternativen Befehl abgesetzt hat, der ebenfalls das Ende der Konversation zufolge hat. So steht es dem Nutzer frei, die Konversation jederzeit zu beenden. 
        
            
        \subsection{telephone.py} \label{Implementierung: telephone.py}
            %\subsubsection{Methode telephone}
                Die Methode \verb|telephone| funktioniert exakt gleich wie die Methode \verb|email|.

            %\subsubsection{Methode skip\_telephone}
                Die Methode \verb|skip_telephone| bietet dem Nutzer an, den Kontakt mit dem Anbieter alternativ via dem auf der Internetseite verfügbaren Webformular zu suchen. \footnote{Dies ist generell für alle Informationen möglich, die an den Bot übergeben werden, allerdings lag der Beweggrund für die Erstellung des Bots darin, eine Alternative zum klassischen Kommunikationsmedium Web-Formular zu bieten.}
        
        
        \subsection{location.py} \label{Implementierung: location.py}
            %\subsubsection{Methode location}
                Der Nutzer hat hier die Möglichkeit, seinen Standort anzugeben. Dazu wird die bereits in Telegram vorhandene Funktion zur Standortfreigabe genutzt. \\
                Am Ende der Methode, bevor der Bot zur nächsten Stufe \verb|PHOTO| weitergeht, sendet der Bot ein Bild von sich selbst, um den Nutzer dazu anzuregen, auch ein Bild von sich zu teilen. Dazu wird ein einfaches JPG verwendet, das im Repository des Bots gespeichert ist. Der Pfad kann leicht an jede andere Ressource angepasst werden.

            %\subsubsection{Methode skip\_location}
                %Keine Besonderheiten.
        

        \subsection{photo.py} \label{Implementierung: photo.py}
            %\subsubsection{Methode photo}
                Entscheidet der Nutzer sich, ein Bild mit dem Bot zu teilen, so nimmt die Methode \verb|photo| dieses entgegen und speichert es in einem Ordner, der je nach System gewählt werden kann. Hier wurde ein Ordner im gleichen Verzeichnis gewählt, in dem der Bot existiert. Um Bilder später wieder zuordnen zu können, wird der Dateiname jedes Bildes auf die user\_ID des jeweiligen Nutzers gesetzt, bevor es gespeichert wird.

            %\subsubsection{Methode skip\_photo}
                %Keine Besonderheiten.
        

        \subsection{summary.py} \label{Implementierung: summary.py}
            %\subsubsection{Methode summary}

            \begin{lstlisting}[language=Python, caption={summary.py - Zusammenfassung für den Nutzer direkt im Messenger}\label{code: summary.py}]
def summary(update: Update, context: CallbackContext) -> int:
    
    user_id = update.message.from_user.id    

    logger.info(f'+++++ User {update.message.from_user.first_name} 
    COMPLETED SIGN UP. +++++')

    first_name = get_value(user_id, 'first_name')
    last_name = get_value(user_id, 'last_name')
    gender = get_value(user_id, 'gender')
    birthdate = get_value(user_id, 'birthdate')
    email = get_value(user_id, 'email')
    telephone = get_value(user_id, 'telephone')

    summary = f"""
        Given Name:\t\t{first_name}
        Last Name:\t\t{last_name}
        Gender choice:\t\t{gender}
        Birthdate:\t\t\t{birthdate}
        Email address:\t\t{email}
        Phone number:\t{telephone}
        """

    # confirmation message
    update.message.reply_text(
        f'Thanks for signing up, {update.message.from_user.first_name}!\n\n'
        f'SUMMARY for {update.message.from_user.first_name} 
        {update.message.from_user.last_name}:\n\n{summary}',
        reply_markup=ReplyKeyboardRemove(),
    )
    
    # check, if the user already made an appointment. 
    appointment_made = get_value(user_id, 'appointment')
    
    # If yes, inform. Else, make one.
    if appointment_made == 'None':
        
        update.message.reply_text(
            'Ok. We will look for 3 appointment options 
            you can choose from for your phone call. \n\n'
            '... SEARCHING ...',
            reply_markup=ReplyKeyboardRemove(),
        )

        free_slots = find_slots()

        slot1 = str(free_slots[0])
        slot2 = str(free_slots[1])
        slot3 = str(free_slots[2])

        # next step message
        update.message.reply_text(
            states.MESSAGES[states.APPOINTMENT],
            reply_markup=ReplyKeyboardMarkup(
                [[slot1], [slot2], [slot3]], ['/skip'], 
                one_time_keyboard=True, 
                input_field_placeholder='Choose your slot...'
                )
            )

    else:
        update.message.reply_text(
            f'Cool. You already have an appointment: {appointment_made} \n\n'
            'In case you would like to cancel, you can do so via your calendar app.\n\n'
            'Otherwise, we are looking forward to our call.',
            reply_markup=ReplyKeyboardRemove(),
        )

        return ConversationHandler.END


    # trigger confirmation email
    confirmation_mail(first_name, summary, email)
    insert_update(user_id, 'mail_sent', '1')

    # save state to DB
    insert_update(user_id, 'state', states.APPOINTMENT)
    return states.APPOINTMENT
            \end{lstlisting}

                In der Methode \verb|summary| kommt alles zusammen. Der Nutzer hat nun alle Angaben gemacht oder übersprungen. Die Methode beginnt damit, eine Reihe von Informationen von der Datenbank abzufragen und in Variablen zu speichern. Es werden nur Informationen abgefragt, die auch in der auszugebenden Nachricht genutzt werden sollen. Direkt darauf wird ein String für die zu versendende Nachricht zusammengebaut und gespeichert. Es folgt eine einfache \glqq Danke-Nachricht\grqq an den Nutzer, bevor die eigentliche Logik der Methode beginnt.\\
                \\
                Nun gibt es aus Nutzersicht mehrere Szenarien: Der Bot prüft, ob der Nutzer bereits einen Termin vereinbart hat.
                
                \begin{enumerate}
                
                    \item Option A:  Der Nutzer ist bis zum Zustand \verb|SUMMARY| gekommen, hat die Zusammenfassung ausgegeben bekommen, dann aber keinen Termin vereinbart und den Chat verlassen. Der Nutzer kehrt nun zum Chat zurück und gibt erneut \verb|/start| ein, um seine Konversation wieder aufzunehmen. Der Bot findet den Nutzer in der Datenbank und leitet an die Stufe \verb|SUMMARY| weiter. Der Nutzer kann nun einen Termin vereinbaren. \\
                    
                    \begin{enumerate}
                        \item Der Bot versucht, dem Nutzer jetzt drei mögliche Terminvorschläge zu unterbreiten und startet dazu die Terminfindung (siehe \ref{Implementierung: Kalender} Kalender).
                        \item Sobald die Termine zurückkommen, präsentiert der Bot diese dem Nutzer in Form eines entsprechenden Tastatur-Layouts. Das Layout ist dabei dynamisch und generiert sich bei jeder Abfrage neu.
                    \end{enumerate}
                
                    \item Option B: Der Nutzer ist bis zum Zustand \verb|SUMMARY| gekommen und hat bereits einen Termin vereinbart. In diesem Fall fragt der Bot den Termin von der Datenbank ab und gibt ihn in einer Nachricht an den Nutzer zurück. Gleichzeitig schlägt er dem Nutzer weitere mögliche Befehle vor, die an dieser Stelle Sinn machen und beendet die Konversation.
                
                \end{enumerate}

            Schließlich wird die Methode \verb|confirmation_mail| aufgerufen, die die gleiche Zusammenfassung nochmals per E-Mail an die Adresse des Nutzers sendet (siehe \ref{Implementierung: confirmation_mail.py} confirmation\_mail.py) und die Information darüber, dass an diesen Nutzer bereits eine E-Mail gesendet wurde wird neben den üblichen Abschlussbefehlen in der Datenbank gespeichert.

                    
        \subsection{confirmation\_mail.py} \label{Implementierung: confirmation_mail.py}

        \begin{lstlisting}[language=Python, caption={confirmation\_mail.py - Bestätigung und Zusammenfassung für den Nutzer per E-Mail}\label{code: confirmation_mail.py}]
def confirmation_mail(recipient_name, summary, recipient_address):

    # open connection to mail server and authenticate
    server = smtplib.SMTP_SSL(smtp_address, smtp_port)
    server.login(sender_address, password)

    # create multipart object, the email consists of
    message = MIMEMultipart()

    # defined from address, to address and subject of the email
    message['From'] = sender_address
    message['To'] = recipient_address

    subject = 'Coaching Bot | Confirmation - sign up complete'
    message['Subject'] = subject

    # email body
    body =   f"""Hi {recipient_name}, \t
        thanks for signing up. This is the confirmation for your 
        sign up with the coaching program by wavehoover. \n 
        {summary}\n
        Looking forward to meeting you!\n
        Your wavehoover Team"""
    
    # create the text object for the email
    message.attach(MIMEText(body, 'plain'))

    server.sendmail(message['From'], message['To'], message.as_string())
    server.quit()
        \end{lstlisting}

            %\subsubsection{Methode confirmation\_mail}
                Um dem Nutzer die Zusammenfassung in Form einer E-Mail zukommen zu lassen, muss diese zunächst zusammengesetzt werden. Die Möglichkeit, dies zu bewerkstelligen, bietet die Bibliothek \verb|mime|. \cite{email.mime} Daneben wird die \verb|smtplib|-Bibliothek genutzt, um eine sichere Verbindung zu einem Mail-Server aufzubauen, über den die fertige E-Mail versenden werden kann. \cite{smtplib}\\

                Erforderliche Zugangsdaten werden außerhalb der Methode \verb|confirmation_mail| aus den \verb|constants| abgefragt und für die Verwendung innerhalb der Methode gespeichert. So werden diese nicht bei jedem Methodenaufruf erneut abgerufen.\\
                \\
                Die Methode bekommt Empfänger-Name sowie -Adresse und die Zusammenfassung aus der Methode \verb|summary| übergeben. Über die \verb|smtplib| wird ein Server-Objekt erstellt. Gegenüber diesem Server authentifiziert sich der Bot nun via Benutzername und Passwort.\\
                War die Authentifizierung erfolgreich, wird die eigentliche Nachricht zusammengesetzt. Dazu benötigt werden vier Bauteile: 
                \begin{enumerate}
                    \item Sender-Adresse
                    \item Empfänger-Adresse
                    \item Betreff
                    \item Nachricht
                \end{enumerate}
                Die Nachricht wird zuerst via der Methode \verb|attache| zusammengesetzt, um dann aus dem vordefinierten String ein \verb|message|-Objekt zu konstruieren.\\
                Schließlich kann die E-Mail via der Methode \verb|sendmail| unter Verwendung des zuvor beschriebenen Mail-Servers versendet werden.\\
                \\
                Schließlich wird die Verbindung zum Server wieder getrennt.


        \subsection{appointment.py} \label{Implementierung: appointment.py}

        \begin{lstlisting}[language=Python, caption={appointment.py - Konstruktion des Kalender-Events}\label{code: appointment.py}]
def appointment(update: Update, context: CallbackContext) -> int:

    user_id = update.message.from_user.id

    # first_name = get_value(user_id, 'first_name')
    # last_name = get_value(user_id, 'last_name')
    email = get_value(user_id, 'email')
    telephone = get_value(user_id, 'telephone')

    summary = 'wavehoover | Coaching Session'
    
    slot_start = update.message.text
    dt_slot_start = datetime.strptime(slot_start, '%Y-%m-%d %H:%M:%S')
    iso_slot_start = str(dt_slot_start.isoformat('T') + '+01:00')
    logger.info(f'>>>>> ISO_SLOT_START: {iso_slot_start}')

    slot_end = str(dt_slot_start + timedelta(minutes=50))
    dt_slot_end = datetime.strptime(slot_end, '%Y-%m-%d %H:%M:%S')
    iso_slot_end = str(dt_slot_end.isoformat('T') + '+01:00')
    logger.info(f'>>>>> ISO_SLOT_END: {iso_slot_end}')

    # uuid = str(str(user_id) + str(randint(10000, 99999)))
    # logger.info(f'>>>>> UUID for user_id {user_id}: {uuid}')

    # build the event data into the event object
    event = {
        f'summary': summary,
        'location': 'Phone Call',
        'description': f'Your coach will call you 
        under the following number: {telephone}',
        'start': {
            'dateTime': iso_slot_start,
            'timeZone': 'Europe/Berlin',
        },
        'end': {
            'dateTime': iso_slot_end,
            'timeZone': 'Europe/Berlin',
        },
        # 'id': uuid,
        # 'recurrence': [
            #'RRULE:FREQ=DAILY;COUNT=2'
        # ],
        'attendees': [
            {'email': email},
        ],
        'reminders': {
            'useDefault': False,
            'overrides': [
            {'method': 'email', 'minutes': 24 * 60},
            {'method': 'popup', 'minutes': 60},
            ],
        },
        }
        \end{lstlisting}

            %\subsubsection{Methode appointment}
                Ziel der Methode \verb|appointment| ist es, den Zeitstempel vom Nutzer entgegenzunehmen, ein Kalender-Event zu bauen und dieses an die Methode \verb|make_appointment| zu übergeben. \\
                Dazu fragt sie zunächst alle erforderlichen Informationen bei der Datenbank ab. Der erhaltene Zeitstempel für den Beginn des Zeitfensters wird dann in ein Format übersetzt, das die Google Calendar API akzeptiert: \\ 
                \verb/%Y-%m-%dT%H:%M:%S+01:00/ \\
                Das Ende des Zeitfensters wird auf 50 Minuten nach dem Start gesetzt und die beiden korrekt formatierten Zeitstempel in das Event verbaut.\footnote{Format und Aufbau des Events können via dem Google APIs Explorer getestet werden. \cite{apiExplorer})} \\
                Ist der Aufruf an die Methode \verb|make_appointment| abgesetzt und ohne Fehler zurückgekehrt, so wird die Datenbank entsprechend um den Start-Zeitstempfel erweitert und eine Bestätigung auf der Konsole ausgegeben. Der Nutzer wird außerdem über den Abschluss seiner Anmeldung informiert. 

            %\subsubsection{Methode skip\_appointment}
                Überspringt der Nutzer diesen letzten Schritt, gibt ihm die Methode \verb|skip_appointment| lediglich eine Nachricht aus, die die Option offen lässt, auf anderem Weg mit dem Anbieter in Kontakt zu treten.

        
        \subsection{help.py} \label{Implementierung: help.py}
            %\subsubsection{Methode help}
                Die Methode \verb|help| setzt ein sog. Dictionary aus einer Liste an Befehlen zusammen, das flexibel befüllt und dann ausgegeben werden kann. Ein Dictionary bietet die Möglichkeit, die Hilfe jederzeit einfach anzupassen, um Elemente zu erweitern oder zu reduzieren, ohne die Logik, über die die Hilfe ausgegeben wird, zu beeinflussen. Dazu wird die \verb|collections|-Bibliothek eingebunden, die es erlaubt, ein geordnetes Dictionary zu erstellen. Nachdem der String für die Hilfe zusammengesetzt ist, wird dieser einfach via der Methode \verb|send\_message| ausgegeben.


        \subsection{states.py} \label{Implementierung: states.py}
            %\subsubsection{STATES}
                Die State Machine muss zu jeder Zeit wissen, welche Zustände es gibt und in welcher Reihenfolge diese existieren. Dazu nutzt der \verb|python-conversation-bot| \cite{conversationBot} ein Array aus Konstanten (STATES). So lässt sich die Reihenfolge der Zustände auch ganz leicht ändern. Soll der Bot bspw. E-Mail und Telefonnummer zu Anfang abfragen oder sollen einige Schritte aus dem Konversationsfluss genommen werden, so sind diese hier einfach zu entfernen und die Nachrichten in den eizelnen Stufen leicht anzupassen.

            %\subsubsection{MESSAGES}
                Um Nachrichten an den Nutzer zentralisiert zu verwalten, verweisen Handler-Functions wo immer möglich auf eine Konstante aus dem \verb|MESSAGES|-Dictionary. So wird vermieden, dass Strings bei Anpassungen der Zustände oder deren Reihenfolge in mehreren Dateien angepasst werden müssen.
            
            %\subsubsection{KEYBOARD\_MARKUPS}
                Gleiches gilt für individuelle Tastaturen aus dem \verb|KEYBOARDS|-Dictionary. 

        \subsection{status.py} \label{Implementierung: status.py}
            %\subsubsection{Methode status}
                Zu jedem Zeitpunkt, kann der Nutzer seinen aktuellen Status abfragen. Dazu prüft die Methode \verb|status| zunächst, ob der Nutzer überhaupt in der Datenbank existiert. Hat der Nutzer seine Informationen nämlich gelöscht, existiert er für den Bot nicht. Zwei Szenarien: 
                \begin{enumerate}
                    \item Der Bot findet den Nutzer, gibt den aktuellen Status zurück und beendet die Konversation.
                    \item Der Bot findet den Nutzer nicht und zeigt dem Nutzer Optionen an, fortzufahren - namentlich die Hilfe aufzurufen oder eine neue Konversation mit dem Bot zu starten.
                \end{enumerate}
        

        \subsection{Input-Validierung: validation.py} \label{Implementierung: validation.py}
            Alle Input-Validation-Methoden sind ähnlich mit einem \verb|try/except| oder \verb|if/else| Block aufgebaut.

            %\subsubsection{validate\_birthdate}
                Die Methode dem \verb|validate_birthdate| bekommt die Nutzereingabe übergeben und vergleicht diese via der Methode \verb|strptime| aus der \verb|datetime|-Bibliothek \cite{datetime} mit dem in der DACH-Region gängigen Datums-Format: \verb|TT.MM.JJJJ| \\
                Stimmt die Eingabe mit dem definierten Format überein, gibt die Methode \verb|True| zurück. Ansonsten wird ein \verb|ValueError| geloggt und die Methode gibt \verb|False| zurück.

            %\subsubsection{validate\_email}
                Die Methode \verb|validate_email| bedient sich eines regulären Ausdrucks, um zu prüfen, ob die Eingabe eine E-Mail sein könnte: \\
                \\
                \verb/[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}/\footnote{Ein vollumfänglicher regulärer Ausdruck, ein externder Dienst oder gar das versenden einer Test-E-Mail wurden aus Performance-Gründen ausgeschlossen.} \\ 
                \\
                Ist der Vergleich erfolgreich, gibt die Methode \verb|True| zurück, ansonsten \verb|False|.

            %\subsubsection{validate\_telephone}
                Auch Telefonnummern werden via regulärem Ausdruck geprüft: \\\verb/^\+4[139]\d{9,12}$/ \\
                Zugelassen sind so alle Telefonnummern aus Deutschland, Österreich und der Schweiz.\\
                Ist der Vergleich erfolgreich, gibt die Methode \verb|validate_telephone| \verb|True| zurück, ansonsten \verb|False|.

        
        \subsection{cancel} \label{Implementierung: cancel.py}
            %\subsubsection{Methode cancel}
                Wurde eine Konversation mit dem Main-ConversationHandler gestartet, so kann diese auch manuell wieder beendet werden. So hat ein Nutzer, wann immer er sich im Konversationsfluss befindet, die Möglichkeit den Befehl \verb|/cancel| abzusetzen. Da dieser Befehl im Main-CommandHandler als Fallback definiert ist, kann der Befehl nur abgesetzt werden, solange dieser aktiv ist. Wird die Methode \verb|cancel| aufgerufen, so wird ein Log-Eintrag über den Abbruch der Konversation abgesetzt. Direkt darauf werden alle Daten des Nutzers aus der Datenbank gelöscht und eine Bestätigung an den Nutzer ausgegeben. Sollte es bei diesem Vorgang zu einem Fehler kommen, so wird der Nutzer auch darüber benachrichtigt und es werden sowohl der Fehler, als auch ein Log-Eintrag in der Konsole ausgegeben. Diese Ausnahme tritt auf, wenn der Nutzer seine Daten bereits gelöscht und den Bot noch nicht neu gestartet hat - es ihn also in der Datenbank gar nicht gibt oder (sehr selten), falls die SQL-Operation nicht erfolgreich war.
                Schließlich beendet der Bot die Konversation.

            %\subsubsection{Methode delete}
                Grundsätzlich handelt es sich bei der Methode \verb|delete| um fast den gleichen Funktionsumfang, wie bei der Methode \verb|cancel|. Allerdings ist sie nicht Bestandteil des Main-ConversationHandlers, sondern in ihrem eigenen Handler definiert und kann somit zu jederzeit über den Befehl \verb|/delete| aufgerufen werden. So ist dafür gesorgt, dass der Nutzer seine Daten auch löschen kann, wenn die Konversation mit dem Bot aus irgendeinem Grund unterbrochen oder bereits beendet wurde.


    \section{Datenbank} \label{Implementierung: Datenbank}

        In diesem Abschnitt wird die Funktionsweise des Database-Connectors erleutert. Alle Methoden sind ähnlich aufgebaut. Zunächst wird eine Verbindung zur Datenbank geöffnet, es finden diverse Prüfungen statt, eine CRUD-Operaion wird abgesetzt und die Antwort entweder innerhalb der Methode analysiert und ein \verb|Boolean| oder der übergebene Wert aufbereitet und im entsprechenden Format zurückgegeben.
                
        \subsection{create\_db.py}
            %\subsubsection{Methode create\_db}
            Es wird versucht, eine Verbindung zur Datenbank \verb|db| aufzubauen. Ist dies erfolgreich, wird der \verb|cursor| erstellt, über den alle folgenden Operationen an die Datenbank kommuniziert werden. Ist dies nicht erfolgreich, wird eine neue Datenbank erstellt.\\
            Ist die Datenbank verfügbar und wurde eine Verbindung aufgebaut, so wird zunächst geprüft, ob es die Tabelle \verb|users| schon gibt. Ist dem so, wird die Methode mit einem Commit und dem Schließen der Verbindung zur Datenbank, beendet. Ist dem nicht so, wird die Tabelle für die Benutzer instanziiert. Aufgrund der Simplizität der gespeicherten Daten kommt der Bot mit einer Tabelle aus.


        \subsection{select\_db.py} \label{Implementierung: select_db.py}

            %\subsubsection{Methode user\_search}
            An \verb|user-search| bekommt eine Nutzer-ID übergeben und prüft, ob ein Nutzer in der Datenbank existiert. Falls ja, wird \verb|True| zurückgegeben - ansonsten \verb|False|.

            %\subsubsection{Methode get\_all\_data}
                An \verb|get_all_data| wird ebenfalls eine Nutzer-ID übergeben und direkt eine Abfrage für alle Informationen abgesetzt, die es über diesen Nutzer gibt. Die Methode iteriert über alle Einträge, die gefunden wurden und gibt die Daten als Liste und in der Konsole zurück.
                
            %\subsubsection{Methode get\_customers}
                Die Methode \verb|get_customers| hat keine Input-Parameter, sondern gibt einfach die gesamte Nutzertabelle aus und als Liste zurück.

            %\subsubsection{get\_value}
                An \verb|get_value| werden eine Nutzer-ID sowie eine Spaltenbezeichnung übergeben. So kann ein spezifischer Wert aus der Datenbank abgerufen werden. \footnote{Die meisten Handler-Functions bedienen sich dieser Funktion.} 
                \begin{lstlisting}[language=Python, caption={select\_db.py - Datenbankabfrage einzelner Nutzerinformationen}\label{code: select_db.py}]
# get a specific value of a user
def get_value(user_id, column):
    # connect to db
    connection = sqlite3.connect(db)

    # cursor
    cursor = connection.cursor()

    selection = f"""SELECT {column}
        FROM users
        WHERE user_id = {user_id}
        """

    # execute command to fetch all data from table users
    cursor.execute(selection)

    # store all data from selection in table_data
    table_value = (str(cursor.fetchone())).lstrip("('").rstrip("',)")

    # print value
    logger.info(f'>>>>> {column} FOUND for user_id: {user_id} >>>>> {table_value}')

    return table_value
                \end{lstlisting}

        \subsection{insert\_value\_db.py} \label{Implementierung: insert_value_db.py}
            %\subsubsection{Methode insert\_update}
                Um sicherzustellen, dass eine Datebank existiert, wird zunächste \verb|create_db| aufgerufen. Diese kommt schnell zurück, da die Datenbank in den meisten Fällen bereits existiert. Nun wird in einem \verb|try/except|-Block versucht, einen existierenden Datenbankeintrag zu aktualisieren. Das funktioniert meistens, weil der Datensatz für einen Nutzer bereits bei der Eingabe von \verb|/start| durchgeführt wird. So kann ein Eintrag bereits von Beginn an immer weiter angereichert werden. Nachdem der Eintrag erfolgreich aktualisiert wurde, gibt es noch einen Log-Eintrag auf der Konsole.

                \begin{lstlisting}[language=Python, caption={select\_db.py - Datenbankabfrage einzelner Nutzerinformationen}\label{code: select_db.py}]
def insert_update (user_id, column, value):

    # create db if non-existent
    create_db()

    # connect to db
    connection = sqlite3.connect("coachingBotDB.db")
    # cursor
    cursor = connection.cursor()

    try:
        cursor.execute('INSERT INTO users (user_id) VALUES (?)', (user_id,))
        logger.info (f'+++++ CREATED record {user_id}: {cursor.lastrowid} +++++')
    except sqlite3.IntegrityError:
        logger.info("+++++ FOUND record... UPDATING... +++++")

    # sql command to UPDATE an existing record
    update_command = f"UPDATE users SET {column} = ? WHERE user_id = ?"
    update_args = (value, user_id)

    cursor.execute(update_command, update_args)
    logger.info (f'+++++ UPDATED record {user_id}: {column} >> {value} +++++')

    # commit changes to db
    connection.commit()
    # close connection
    connection.close()

                \end{lstlisting}
        
        \subsection{insert\_update\_db.py} \label{Implementierung: insert_update_db.py}
            %\subsubsection{Methode insert\_update}
                Die Methode funktioniert ähnlich wie die Methode \verb|insert_update| aus der \\\verb|insert_value_db.py|. Sie unterscheidet sich darin, dass sie alle Parameter für den gesamten Datenbankeintrag eines Nutzers übergeben bekommt. So ist es möglich, einen Nutzer zu Testzwecken auf einmal in die Datenbank einzufügen, ohne den Bot jedes Mal zu durchlaufen zu müssen.
        
        \subsection{delete\_record.py} \label{Implementierung: delete_record.py}
            %\subsubsection{Methode delete\_record}
                Die Methode \verb|delete_record| bekommt eine Nutzer-ID übergeben und prüft zunächst via der Methode \verb|user_search|, ob es den Nutzer mit der angegebenen Nutzer-ID überhaupt gibt. Falls ja, wird in einem \verb|try/except|-Block versucht, alle Informationen eines Nutzers via SQL-Befehl zu löschen. 

            %\subsubsection{Methode delete\_value}
                Die Methode \verb|delete_value| ist mit der Methode \verb|delete_record| fast identisch. Hier wird aber zusätzlich eine Spaltenbezeichnung übergeben, die es ermöglicht, nur einen einzelnen Wert zu löschen.


    \section{Kalender} \label{Implementierung: Kalender}
        
        \subsection{calendar\_manager.py} \label{Implementierung: calendar_manager.py}
        Der Kalender Manager basiert auf der \verb|quickstart.py|, die von Google als Starter-Kit für einige gängige Programmiersprachen angeboten wird. (Setup beschrieben in \ref{Grundlagen} Grundlagen) Daneben nutzt der Kalender Manager Pythons native Bibliotheken zum Zusammenfügen von Dateipfaden sowie die Mathode \verb|get_value| aus dem Database Connector. Er erlaubt es dem aufrufenden System, abzufragen, ob eine Zeitspanne verfügbar ist und Termine zwischen einer festgelegten Veranstalter-Adresse und beliebig vielen Teilnehmer-Adressen zu erstellen und zu versenden. Im Folgenden werden die dazu erforderlichen Methoden und Schritte erklärt. 

            %\subsubsection{Methode main}
                Die \verb|main|-Methode des Kalender Managers authentifiziert sich gegenüber der Google Calendar API und versucht daraufhin, die nächsten zehn Elemente des Kalenders auszugeben. Ist die Authentifizierung nicht erfolgreich, wird ein \verb|HTTP|-Error ausgegeben. (siehe \ref{Google Calendar API} Google Calendar API)

            %\subsubsection{Methode authenticate}
                \verb|authenticate| ist eine reduzierte Version der \verb|main|-Methode. Sie gibt ein \verb|service|-Objekt zurück, das genutzt werden kann, um die Methoden der Google Calendar API anzusprechen und auszuführen. 
    
            %\subsubsection{Methode check\_availability}

            
            Die Methode \verb|check_availability| nimmt einen Start- und einen Endzeitpunkt entgegen und formatiert diese so um, dass sie dem RFC3339-Format entsprechen. Das Format setzt sich zusammen wie folgt: \\
            \\
            YYYY-MM-DD, \glq T\grq, HH:MM:SS.ms, Buchstabe \glq Z\grq \\
            \\
            Beispiel für 10:05 Uhr vormittags am 28.02.2022, koordinierte Weltzeit (UTC): \\
            \\
            \verb/2022-02-28T10:05:00.00Z/ \\
            \\
            Weitere Informationen zum RFC3339-Format finden sich im offiziellen Standard. \cite{date_time} \\
            
            Die beiden Zeitstempel werden in einer Anfrage an die Calendar API eingebaut, an diese übergeben. Die Methode versucht darauf, die Methode \verb|freebusy| der API abzufragen. Ist dies erfolgreich, gibt die API eine Antwort im \verb|JSON|-Format zurück, das Python als Dictionary interpretiert und in mehreren geschachtelten Schleifen auslegen kann. Ist das Feld \verb|busy: []| leer, so wird \verb|True| zurückgegeben. Das Zeitfenster ist frei. Ist das Feld nicht leer, gibt es einen Terminkonflikt. Die Methode gibt \verb|False| zurück. \\
            \\
            Erzeugt dieser Vorgang einen Fehler, wird ein \verb|HTTP|-Error auf der Konsole ausgegeben. \\
            \begin{lstlisting}[language=Python, caption={check\_availability - Anfrage an Google Calendar API}\label{code: check_availability}]
def check_availability(start, end):

    service = authenticate()
    
    logger.info(f'+++++ SLOT START: {start}') # must be in format RFC3339
    logger.info(f'+++++ SLOT END: {end}')

    start_iso = str(start.isoformat('T')+'+01:00') # convert UTC to CET
    logger.info(f'+++++ start_iso: {start_iso}')

    end_iso = str(end.isoformat('T')+'+01:00') # same for end time
    logger.info(f'+++++ end_iso: {end_iso}')

    request = {
        "timeMin": start_iso,
        "timeMax": end_iso,
        "timeZone": "Europe/Berlin", 
        "items": [
            {
            "id": coaching_calendar_ID #put ID incl. the @domain...
            }
        ]
        }

    print (request)
    
    try:
        
        response = service.freebusy().query(body=request).execute()
        logger.info('+++++ CAL: AVAILABILITY CHECKED +++++')
        print('>>>>> HTTP Response' + str(response))
    
        # climb down the dict latter and read the busy response 
        from the HTTP-Response object
        calendars = response.get('calendars')
        print(f'>>>>> CALENDARS: {calendars}')
        calendar_temp = calendars.get(coaching_calendar_ID)
        print(f'>>>>> CALENDAR_TEMP: {calendar_temp}')
        availability = calendar_temp.get('busy')
        print(f'>>>>> AVAILABILITY: {availability}')
        if availability == []:
            return True


    except HttpError as error:
        logger.info('ERROR: %s' % error)
                \end{lstlisting}

            %\subsubsection{Methode find\_slots}
                Die Methode \verb|find_slots| sucht nach drei Zeitfenstern innerhalb der vordefinierten Geschäftszeiten und gibt diese, in Form einer Liste zurück. \\
                \\
                Die Suche für Termine startet um 08:00 Uhr am kommenden Arbeitstag. Es wird zwischen heute und morgen 08:00 Uhr unterschieden. Ist der Zeitstempel zur Zeit der Ausführung der Methode vor 08:00 Uhr, so wird die Suche heute um 08:00 Uhr begonnen. Ist es bereits nach 08:00 Uhr, so wird die Suche am nächsten Tag begonnen. Das Resultat ist der Zeitstempel von heute oder morgen 08:00 Uhr, der als Startzeit für die Suche verwendet wird. \\
                \\
                Nun wird die Google Calendar API für das erste Zeitfenster abgefragt. Ist das Fenster frei, übernimmt die Methode den Slot und fährt mit der Suche fort. Der nächste Termin wird drei Tage später gesucht, um mehrere unterschiedliche Termine anbieten zu können. \\
                \\
                Ist ein Fenster belegt, so wird der Slot zur nächsten vollen Stunde geprüft und dies solange, bis drei Termine gefunden sind. Neben der Rückgabe als Liste erfolgt eine Ausgabe auf der Konsole.\\
                \\
                Wochenenden und Zeiten vor 08:00 sowie nach 18:00 Uhr werden übersprungen, da die Methode \verb|check_availability| für diese Zeiten immer \verb|False| zurückgibt.\footnote{Welche Zeiten als busy zurückgegeben werden kann einfach im eigenen Kalender-Client angepasst werden. Eine Anpassung im Code ist nicht erforderlich.}

                \begin{lstlisting}[language=Python, caption={find\_slots - Sucht drei Terminvorschläge heraus}\label{code: find_slots}]
def find_slots():

    # Get today's datetime
    datenow = datetime.datetime.now()

    # Create datetime variable for 8 AM
    dt8 = None

    # If today's hour is < 8 AM
    if datenow.hour < 8:

        # Create date object for today's year, month, day at 8 AM
        dt8 = datetime.datetime(datenow.year, datenow.month, datenow.day, 8, 0, 0, 0)

    # If today is past 8 AM, increment date by 1 day
    else:

        # Get 1 day duration to add
        day = datetime.timedelta(days=1)

        # Generate tomorrow's datetime
        tomorrow = datenow + day

        # Create new datetime object using tomorrow's year, month, day at 8 AM
        dt8 = datetime.datetime(tomorrow.year, tomorrow.month, tomorrow.day, 8, 0, 0, 0)

    # Create timestamp from datetime object
    # timestamp = time.mktime(dt8.timetuple())
    
    # within the business hours, find 3 free time slots to suggest to the user
    free_slots = []
    slots = 0
    start = dt8
    round = 0
    while slots < 3:
        round += 1
        end = start + datetime.timedelta(minutes=50)
        
        if (check_availability(start, end)): 
            free_slots.append(str(start))
            slots += 1;

            print(f'>>>>> Slot found at: {start} <<<<<')
            start = dt8 + datetime.timedelta(days=3*slots)

        else: 
            logger.info ('##### NO SLOT FOUND #####')
            start = start + datetime.timedelta(hours=1)
        
        print (f'##### {slots} slots found in {round} rounds. #####') 
        # tell me, how many rounds the while loop has to run to get 3 slots

    print(f'>> FREE SLOTS: {free_slots}')
    return free_slots
                \end{lstlisting}


            %\subsubsection{Methode make\_appointment}
                Abschließend hat der Nutzer die Möglichkeit, einen der drei Vorschläge auszuwählen. Dieser Vorschlag wird neben der Nutzer-ID in zweierlei Form an die Methode \\\verb|make_appointment| übergeben - einmal als \verb|String| und einmal als \verb|Calender|-Event. \\
                Das Event wird inkl. der Kalender-ID an die API via der Methode \verb|insert| übergeben und so in den entsprechenden Kalender eingefügt. \\
                Falls bei dieser Operation ein Fehler passiert, wird ein \verb|HTTP|-Error auf der Konsole ausgegeben.

                \begin{lstlisting}[language=Python, caption={make\_appointment - Terminvereinbarung und Erstellung Kalender Event in Google Calendar}\label{code: make_appointment}]
def make_appointment(user_id, slot_start, event):

    service = authenticate()

    try:
        service.events().insert(calendarId=coaching_calendar_ID, body=event).execute()
        logger.info(f'+++++ APPOINTMENT MADE for {user_id} at {slot_start}')

    except HttpError as error:
        logger.info('ERROR: %s' % error)

    return
                \end{lstlisting}

    
    \section{Web-GUI}
        Die Web-GUI wird komplett mit Flask erstellt. Dazu benötigt werden die Applikation für den Web-Server sowie das Templating selbst (\verb|app.py|), ein HTML- (\verb|home.html|) und ein CSS-File (\verb|main.css|), über das Inhalt und Style definiert werden sowie wenige Ressourcen. Alle anderen Elemente liegen bereits vor.
        
        \subsection{app.py} \label{Implementierung: app.py}
            Die \verb|app.py| instanziiert via der Flask Bibliothek einen Webserver und konstruiert den darzustellenden Inhalt in Form eines sog. Templates. Dieses wird aus Nutzerinformationen zusammengesetzt, die bei Aufrufen der entsprechenden URL aus der Datenbank abgefragt werden sowie aus den von Nutzern eingereichten Bildern. 
            Das fertige Template wird dann an den Webserver zurückgegeben.

        \subsection{home.html} \label{Implementierung: home.html}
            Die \verb|home.html| besteht aus drei Teilen. Zunächst wird eine Tabelle erstellt und mit den für die Darstellung der Daten aus der Datenbank erforderlichen Spalten versehen. Daraufhin werden die Daten aus der Datenabank, die eine andere Spaltenreihenfolge haben, als die, in der sie hier dargestellt werden sollen, den entsprechenden Spalten zugeordnet.
            Schließlich wird eine Google Calendar View via iframe eingebunden.
            Die Ansicht aktualisiert sich nicht in Echtzeit, sondern nur auf Anfrage, da eine Veränderung der Daten nur selten zu erwarten ist.

        \subsection{main.css} \label{Implementierung: main.css}
            Es kommt ein minimalistisches CSS-Template zum Einsatz, das den Ansprüchen, Nutzerdaten einzusehen leicht genügt.\\ \\

        Über die IP-Adresse \verb|127.0.0.1| und Port \verb|5000| ist die GUI als Admin zu erreichen\footnote{Um das Kalender-Feature einsehen zu können, ist eine Anmeldung mit dem entsprechenden Google-Konto erforderlich.}: \url{http://127.0.0.1:5000/} 


    % \section{Tests}
    %         Das Haupt-Test-Instrument ist die Telegram-App selbst. Daneben wurden 2 Testskripte zum einfachen Testen verschiedener Teile der App geschrieben. Tests sind getrennt und entsprechend ein- oder auskommentiert. 