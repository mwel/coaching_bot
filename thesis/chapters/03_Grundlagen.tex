\chapter{Grundlagen} \label{Grundlagen}
Die folgenden Sprachen und Systeme und deren grundsätzliches Verständnis dienen als Grundlage für die im Rahmen dieses Projekts entwickelte Applikation. Eine Liste aller eingebundenen Bibliotheken kann dem Pipfile des Projets entnommen werden. 


    \section{Python}
        Python ist aufgrund ihrer Simplizität beim Erlernen und im Syntax sowie ihrer Interpretationsfähigkeit eine der populärsten Programmiersprachen des 21. Jahrhunderts, was dem Anwender im Hinblick auf die Anforderung, den Code leicht und ohne umfangreiche Vorkenntnisse adaptieren zu können, entgegen kommt. Um den CoachingBot zu programmieren wird eine Sprache bevorzugt, die für Server-seitiges Development geeignet ist, geskriptete Abläufe gut abbilden kann, einfache Bindungs-Mechaniken an Datenbanken bereithält und dem Entwickler die Freiheit lässt, seine Applikation methodisch, objektorientiert oder prozedural zu entwickeln.\cite{python} Python erfüllt nicht nur all diese Anforderungen - auch die Telegram-API ist für Python-Implementierungen geschrieben.\footnote{\url{https://python-telegram-bot.org/} Andere Sprachen sind verfügbar, aber nicht einfacher und bauen ebenfalls auf der Python-Version der Telegram-API auf.}
        Der größte Teil der Applikation ist daher in Python 3.8.6 \cite{python3.8.6} geschrieben.\footnote{Das war zum Stand des Entwicklungsbeginns 2021 die aktuell stabile Python-Version.} 
        Für einen Einstieg in die Programmiersprache Python und als Vorbereitung auf Kapitel \ref{Implementierung} Implementierung wird das benutzerfreundliche Python Tutorial von W3C-Schools empfohlen.\footnote{\url{https://www.w3schools.com/python/default.asp}}

    \section{Telegram Chat Bots}
        Telegram Chat Bots sind Applikationen, die auf einer quelloffenen API \cite{telegramAPI} basieren, auf allen Komplexitätsstufen adaptierbar sind und es jedermann ermöglichen, einen Chatbot zu bauen. Die einzige suboptimale Einschränkung besteht im Vendor Lock-In der Telegram-App. (Der Bot ist nur in Verbindung mit der Telegram-App \cite{telegram} nutzbar.) Aufgrund der technischen Vorteile, die dieses Framework bietet, ist dieser Nachteil jedoch in einer ersten Version in Kauf zu nehmen. Sollte das Prinzip Erfolg versprechen, so kann die Logik mittels Frameworks wie \ref{BotMan} Botman auf andere Umgebungen erweitert werden.
        Die meisten Menschen in Deutschland und der DACH-Region verwenden immer noch WhatsApp \cite{Nutzerzahlen} und doch bietet uns der populärste Messenger nicht die Freiheiten und den Funktionsumfang, den wir uns für unseren CoachingBot wünschen. Telegram jedoch hält genau diese Offenheit für uns bereit. \cite{telegramVergleich} So bietet der Dienst, die Möglichkeit, via einer API direkt in die Entwicklung einzusteigen und hält sogar basale State-Machines für uns bereit, die uns die Komplexität für den Kern des Bots nicht komplett abnehmen, aber als Gerüst für den CoachingBot dienen können.

    \section{Telegram API Framework}
        Große Teile des CoachingBots basieren auf der API des Instant Messaging Dienstes Telegram\cite{telegramAPI} sowie deren Extension \cite{telegramAPIext}. 

        \subsection{Telegram API} \label{Telegram API}
            \glqq Die Telegram Bot-API ist eine HTTP-basierte Schnittstelle für Entwickler, die Bots für Telegram erstellen möchten.\grqq \cite{core_telegram_api} 


        \subsection{Telegram API Extension}\label{Telegram API Ext}
            Die \verb|telegram.ext| baut auf der reinen API-Implementierung aus \ref{Telegram API} auf. Sie besteht aus mehreren Klassen. Die beiden Wichtigsten für den CoachingBot sind \verb|telegram.ext.Updater| und \verb|telegram.ext.Dispatcher|. Die Updater-Klasse holt kontinuierlich neue Aktualisierungen von Telegram ab und gibt sie an die Dispatcher-Klasse weiter. Ein Updater-Objekt erstellt einen Dispatcher und verknüpft diesen mit einer Warteschlange. Im Dispatcher-Handler können dann verschiedene Typen registriert werden, die die vom Updater abgeholten Aktualisierungen entsprechend den registrierten Handlern sortieren und an eine vordefinierte Callback-Funktion übergeben. Für die Nutzung ist ein Access Token erforderlich.\cite{telegram_ext_intro} Mehr Informationen dazu, wie ein solches Token erstellt wird in Abschnitt Realisierung \ref{botfather}.


    \section{ConversationBot}
        Das hier verwendete Kernelement des CoachingBots - die Finite State Machine (z.dt. Endlicher Automat, im Folgenden nur \glqq State Machine\grqq) - basiert auf dem ConversationBot von Leandro Toledo et. al. \cite{conversationBot}.\footnote{Das Repository enthält eine Vielzahl basaler Bot-Implementierungen, die als Startpunkt für viele Bot-Implementierung einen guten Einblick in mögliche Grundgerüste und Funktionsweisen geben können.} In Abb. \ref{code: ConversationBot} ist eine vereinfachte Version zu sehen. Nach der Einbindung der \verb|telegram|- und \verb|telegram.ext|-Bibliotheken, werden die Zustände der State Machine definiert. In diesem Setup gibt es drei angedeutete Arten von Methoden (später Handler-Functions): die \verb|start|-, die \verb|state[n]|- und die \verb|cancel|-Methode. Erstere und Letztere werden verwendet, um die Konversation mit dem Bot manuell zu starten und zu beenden. Über die \verb|state[n]|-Methoden können Nachrichten an den Nutzer, Konditionen für den Übergang zum nächsten Zustand sowie weitere Zusatzfunktionen ausgelöst werden, die aus dem entsprechenden Zustand resultieren sollen. 
        In der \verb|main|-Methode werden der Updater sowie der Dispatcher inkl. aller Conversation- und Command-Handler angemeldet und konfiguriert. Außerdem wird der Abfrage-Loop an Telegram (Polling) gestartet. Auf die genaue Implementierung wird in Abschnitt \ref{main.py} eingegangen.
        
        \begin{lstlisting}[language=Python, caption={ConversationBot Boiler Plate}\label{code: ConversationBot}]
            from telegram import ReplyKeyboardMarkup, ReplyKeyboardRemove, Update
            from telegram.ext import (Updater, CommandHandler, MessageHandler, Filters,
                ConversationHandler, CallbackContext)
            
            STATE01, STATE02 = range(2)
            
            def start(update: Update, context: CallbackContext) -> int:
                update.message.reply_text('Welcome Message')
                return STATE01
            
            def state01(update: Update, context: CallbackContext) -> int:
                user = update.message.from_user
                update.message.reply_text('state dependant message 
                and transition to next state')
                return ConversationHandler.END
            
            def cancel(update: Update, context: CallbackContext) -> int:
                user = update.message.from_user
                update.message.reply_text('Bye! I hope 
                we can talk again some day.', 
                reply_markup=ReplyKeyboardRemove())
                return ConversationHandler.END
            
            def main() -> None:
                updater = Updater("TOKEN")
                dispatcher = updater.dispatcher
                conv_handler = ConversationHandler(
                    entry_points=[CommandHandler('start', start)],
                    states={STATE01: [MessageHandler(Filters.text & 
                    ~Filters.command, state01)],},
                    fallbacks=[CommandHandler('cancel', cancel)],)
                dispatcher.add_handler(conv_handler)
                updater.start_polling()
                updater.idle()
            
            if __name__ == '__main__':
                main()
        \end{lstlisting}


    \section{SQLite}
        Zur persistenten Speicherung von Nutzerdaten wird eine SQLite Datenbank \cite{sqlite} genutzt. SQLite ist das weltweit am weitesten verbreitete Datenbank-System und bietet mitunter die einfachste und dennoch hinreichend verlässliche und robuste Möglichkeit, Daten über die Lebensdauer des Bots hinaus in einem Datenbankformat zu speichern. SQLite ist vor Allem geeignet für lokal betriebene Applikationen, die realtiv wenige, gleichzeitige Datenbankoperationen erwarten und nicht verteilt sind oder große Enterprise-Grade-Applikationen bedienen müssen. Das System ist kostenlos, wartungsfrei, quelloffen und leicht über die die Bibliothek sqlite3 \cite{sqlite3API} mit dem Python-basierten CoachingBot zu verknüpfen. Der Database-Connector bietet basale CRUD-Operationen, die durch eine einfache Implementierung angesprochen und ohne Weiteres genutzt werden können. In Abschnitt \ref{Realisierung Datenbank} Datenbank wird näher auf die Datenbank-Instanz eingegangen. 


    \section{Mailing-Service und Mail-Server}
        Die Applikation versendet als Bestätigung der Anmeldung eine E-Mail von einem Mail-Server. Dazu wird ein privat gehosteter Mail-Server genutzt. Der Mailing-Service funktioniert mit jedem beliebigen Mail-Server. Zugangsdaten dazu können in den \verb|_constants| angepasst werden. 


    \section{Web-GUI}
        Um dem Coach eine Übersicht über Anmeldungen und Nutzerinformationen bereitzustellen, stellt die Applikation eine Web-GUI via HTML, CSS und Flask bereit. Die GUI kann angepasst werden. Dies ist aber weder für die Verwendung des Bots noch der Übersicht erforderlich. Sollte eine Anpassung an diesem Modul gewünscht sein, sind Grundkenntnisse der drei folgenden Elemente empfohlen: 
        \begin{itemize}
            \item HTML\footnote{\url{https://www.w3schools.com/html/default.asp}} - Mark-Up der im Webbrowser auszugebenden Inhalte
            \item CSS\footnote{\url{https://www.w3schools.com/css/default.asp}} - optische Aufbereitung der Web-GUI via CSS-Stylesheet
            \item Flask\footnote{\url{https://flask.palletsprojects.com/en/2.0.x/\#user-s-guide}} - Audbau eines lokalen Web-Servers, um HTML und CSS an den Browser zu übergeben
        \end{itemize}    

        
    \section{Google Calendar API} \label{Google Calendar API}
        Die Applikation bindet die Google Calendar API \cite{googleCalAPI} an, um es dem User zu ermöglichen, einen Termin mit dem Anbieter zu vereinbaren und diesen später auch wieder in der eigegen Kalender-Applikation abzulehnen.
        Um die API nutzen zu können, bedarf es der Installation der API (via pipenv) und der Einrichtung der quickstart.py. Sie stellt den Rahmen für die Authentifizierung gegenüber dem Google Open\-Authorization (oauth2) Protokoll und bindet erste Bibliotheken ein.\footnote{Eine genaue Dokumentation zu Aufbau und Nutzung der quickstart.py findet sich hier: \url{https://developers.google.com/calendar/api/quickstart/python}}
        Für den CoachingBot ist die quickstart.py bereits konfiguriert und wurde durch einige Erweiterungen zum Calendar Manager weiterentwickelt (siehe \ref{calendar_manager.py} calendar\_manager.py). Zur Nutzung durch Dritte bedarf es dabei individueller Schlüssel sowie Zugangsberechtigungen, durch deren Setup nun geführt wird. Vorgängig ist die Dokumentation zur Google Cloud Console zu sichten. 
        \footnote{\url{https://console.cloud.google.com/}}
        
        \subsection{Scope}
            Die API kann auf verschiedene sog. \glq Scope\grq (z.dt. Umfang oder Reichweite) eingestellt werden. So wird festgelegt, welche Rechte dem Kalender Manager gegenüber der API zur Verfügung stehen und welche Methoden, die die API bietet, genutzt werden können. So wäre bspw. der Scope \glqq.../readonly\grqq verfügbar, über den ein Kalender nur abgefragt, aber keine Termine erstellt werden können. Der Bot nutzt den umfangreichsten Scope.\footnote{\url{https://www.googleapis.com/auth/calendar}}. Über ihn stehen alle Operationen der API zur Verfügung.
        
        \subsection{Zugangsdaten}
            Um sich via OAuth zu authentifizieren, bedarf es folgender Schritte in der Google Cloud Console. Obwohl diese Schritte bereits durchgeführt wurden, so sind diese bei einer Fremdimplementierung dennoch erneut erforderlich - damit die erforderlichen Schlüssel erstellt werden. 
        
            \begin{enumerate}
                \item Erstellung eines Google Accounts
                \item Registrierung dieses Accounts als Google Developer Account
                \item Anlegen eines Projekts in diesem Google Developer Account
                \item Deklaration des Projekts als Testprojekt
                \item Eintragen eines Testers (das Gleiche oder ein anderes Google-Konto kann verwendet werden.)
                \item Generierung eines Schlüsselpaares zur Authentifizierung
                \item Verifizierung der eigenen Website\footnote{\url{https://www.google.com/webmasters/verification/home?hl=en}}
                \item Freigabe der Redirect-URI für dieses Schlüsselpaar
                \item Generierung und Herunterladen der Zugangsdaten (credentials.json)
                \item Installation der quickstart.py im eigenen Repository
                \item Anpassung der quickstart.py (Angabe des Pfads zum credentials.json)
                \item Ausführen der quickstart.py zur Generierung des lokalen Partner\-Tokens für die Authentifizierung
                \item Anpassung der quickstart.py (Angabe des Pfads zum Sicherheits\-Token)
                \item Erneutes Ausführen der quickstart.py, um zu testen, ob die ersten 10 Events des angegebenen Kalenders abgefragt werden konnten.                    
            \end{enumerate}
        
            Bei Erfolg kann die quickstart.py als Testskript bestehen bleiben, wird aber für den Bot nicht mehr benötigt.
        
    \section{TheCoachingBot}
        Der gesamte Quellcode inklusive aller Abhängigkeiten findet sich in einem öffentlichen GitHub-Repository.\footnote{\url{https://github.com/mwel/coaching_bot}}
        \\ \\
        
